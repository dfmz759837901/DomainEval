{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    \n    # Prepare the data\n    if data is not None:\n        if x is not None or y is not None:\n            raise ValueError(\"Cannot provide both 'data' and 'x'/'y'.\")\n        data = pd.DataFrame(data)\n        x = data.iloc[:, 0] if data.shape[1] > 0 else None\n        y = data.iloc[:, 1] if data.shape[1] > 1 else None\n        hue = data[hue] if hue is not None else None\n\n    # Create the axes if not provided\n    if ax is None:\n        ax = plt.gca()\n\n    # Handle hue\n    if hue is not None:\n        if palette is None:\n            palette = plt.get_cmap('viridis', len(hue.unique()))\n        colors = palette(hue) if hue_norm is None else palette(hue_norm(hue))\n    else:\n        colors = [to_rgba('black')] * len(x)\n\n    # Create the rug plot\n    for xi, color in zip(x, colors):\n        ax.add_line(plt.Line2D([xi, xi], [0, height], color=color, **kwargs))\n\n    # Adjust the axes\n    if expand_margins:\n        ax.set_ylim(bottom=-height, top=max(height, ax.get_ylim()[1]))\n\n    # Add legend if required\n    if legend and hue is not None:\n        handles = [plt.Line2D([0], [0], color=palette(i), lw=4) for i in range(len(hue.unique()))]\n        ax.legend(handles, hue_order if hue_order is not None else hue.unique())\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    \n    # Prepare the data\n    if data is not None:\n        if x is not None or y is not None:\n            raise ValueError(\"Cannot provide both 'data' and 'x'/'y'.\")\n        data = pd.DataFrame(data)\n        if hue is not None:\n            hue = data[hue]\n        x = data[x] if x is not None else data.iloc[:, 0]\n        y = data[y] if y is not None else data.iloc[:, 1]\n\n    # If x is not provided, raise an error\n    if x is None:\n        raise ValueError(\"Must provide either 'data' or 'x'.\")\n\n    # Prepare the axes\n    if ax is None:\n        ax = plt.gca()\n\n    # Handle hue\n    if hue is not None:\n        unique_hues = hue.unique()\n        if palette is None:\n            palette = plt.get_cmap('tab10', len(unique_hues))\n        color_map = {h: to_rgba(palette(i)) for i, h in enumerate(unique_hues)}\n        colors = hue.map(color_map)\n    else:\n        colors = [to_rgba('black')] * len(x)\n\n    # Create the rug plot\n    for xi, color in zip(x, colors):\n        ax.add_line(plt.Line2D([xi, xi], [0, height], color=color, **kwargs))\n\n    # Adjust the axes\n    if expand_margins:\n        ax.set_ylim(bottom=-height, top=max(height, ax.get_ylim()[1]))\n\n    # Add legend if required\n    if legend and hue is not None:\n        handles = [plt.Line2D([0], [0], color=color_map[h], lw=4) for h in unique_hues]\n        ax.legend(handles, unique_hues)\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n\n    if data is not None:\n        if x is None and y is None:\n            raise ValueError(\"Must provide either `x` or `y` when `data` is provided.\")\n        if x is not None and y is not None:\n            raise ValueError(\"Cannot provide both `x` and `y` when `data` is provided.\")\n        if x is not None:\n            data = data[x]\n        else:\n            data = data[y]\n\n    if hue is not None:\n        if palette is None:\n            palette = mpl.cm.viridis\n\n        unique_hues = np.unique(hue)\n        if hue_order is not None:\n            unique_hues = [h for h in hue_order if h in unique_hues]\n\n        hue_colors = {h: to_rgba(palette(i / len(unique_hues))) for i, h in enumerate(unique_hues)}\n        colors = [hue_colors[h] for h in hue] if hue is not None else None\n    else:\n        colors = None\n\n    data = np.asarray(data)\n    if colors is not None:\n        data = np.column_stack((data, colors))\n\n    # Create the rug plot lines\n    for i, value in enumerate(data):\n        if colors is not None:\n            color = colors[i]\n        else:\n            color = 'k'  # default color\n\n        ax.add_line(plt.Line2D([value, value], [0, height], color=color, **kwargs))\n\n    if expand_margins:\n        ax.set_ylim(-height, height)\n\n    if legend and hue is not None:\n        handles = [plt.Line2D([0], [0], color=hue_colors[h], lw=4) for h in unique_hues]\n        ax.legend(handles, unique_hues)\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    \n    # Prepare the data\n    if data is not None:\n        if x is None and y is None:\n            raise ValueError(\"Must provide either 'x' or 'y' when 'data' is provided.\")\n        if x is not None and y is not None:\n            raise ValueError(\"Cannot provide both 'x' and 'y' when 'data' is provided.\")\n        if x is not None:\n            data = data[x]\n        else:\n            data = data[y]\n    elif x is None and y is None:\n        raise ValueError(\"Must provide 'data' or 'x' or 'y'.\")\n\n    # Handle hue\n    if hue is not None and data is not None:\n        if len(data) != len(hue):\n            raise ValueError(\"Length of 'hue' must match length of 'data'.\")\n\n    # Create the axes if not provided\n    if ax is None:\n        ax = plt.gca()\n\n    # Prepare the hue mapping\n    if hue is not None:\n        unique_hues = pd.Series(hue).unique()\n        if palette is None:\n            palette = plt.get_cmap('tab10', len(unique_hues))\n        hue_colors = {h: to_rgba(palette(i)) for i, h in enumerate(unique_hues)}\n    else:\n        hue_colors = {None: 'black'}\n\n    # Create the rug plot\n    data = np.asarray(data)\n    for i, value in enumerate(data):\n        color = hue_colors[hue[i]] if hue is not None else hue_colors[None]\n        ax.add_line(plt.Line2D([value, value], [0, height], color=color, **kwargs))\n\n    # Adjust the axes\n    if expand_margins:\n        ax.set_ylim(-height, height)\n\n    # Add legend if required\n    if legend and hue is not None:\n        handles = [plt.Line2D([0], [0], color=color, lw=4) for color in hue_colors.values()]\n        ax.legend(handles, hue_colors.keys())\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "rugplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs):\n    \n    # Prepare the data\n    if data is not None:\n        if x is None and y is None:\n            raise ValueError(\"Must provide either `x` or `y` if `data` is provided.\")\n        if x is not None and y is not None:\n            raise ValueError(\"Cannot provide both `x` and `y`.\")\n        if x is not None:\n            data = data[x]\n        else:\n            data = data[y]\n    else:\n        data = x if x is not None else y\n    \n    # Handle hue\n    if hue is not None:\n        if palette is None:\n            palette = mpl.cm.viridis\n        if hue_order is None:\n            hue_order = np.unique(hue)\n        hue_colors = {h: to_rgba(palette(i / len(hue_order))) for i, h in enumerate(hue_order)}\n        colors = [hue_colors[h] for h in hue]\n    else:\n        colors = [to_rgba('black')] * len(data)\n\n    # Create the rug plot\n    if ax is None:\n        ax = plt.gca()\n\n    # Expand margins if needed\n    if expand_margins:\n        xlim = ax.get_xlim()\n        ylim = ax.get_ylim()\n        ax.set_ylim(ylim[0] - height, ylim[1] + height)\n\n    # Create lines for the rug plot\n    for i, (d, color) in enumerate(zip(data, colors)):\n        ax.add_line(plt.Line2D([d, d], [0, height], color=color, **kwargs))\n\n    # Optionally add a legend\n    if legend and hue is not None:\n        handles = [mpl.lines.Line2D([0], [0], color=hue_colors[h], lw=4) for h in hue_order]\n        ax.legend(handles, hue_order)\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = rugplot(x=[])\n        assert not ax.collections\n    \nTestRugPlot().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestRugPlot(SharedAxesLevelTests):\n    def test_multiple_rugs(self):\n        values = np.linspace(start=0, stop=1, num=5)\n        ax = rugplot(x=values)\n        ylim = ax.get_ylim()\n        rugplot(x=values, ax=ax, expand_margins=False)\n        assert ylim == ax.get_ylim()\n    \nTestRugPlot().test_multiple_rugs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef rugplot(data=None, *, x=None, y=None, hue=None, height=0.025,\n    expand_margins=True, palette=None, hue_order=None, hue_norm=None,\n    legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None):\n    if order is not None:\n        if not isinstance(order, (list, np.ndarray, pd.Index)):\n            raise ValueError(\"Order must be a list-like object.\")\n        return [level for level in order if level in vector and pd.notna(level)]\n    \n    # If no order is provided, determine the unique levels from the vector\n    unique_levels = pd.unique(vector)\n    ordered_levels = [level for level in unique_levels if pd.notna(level)]\n    \n    return ordered_levels", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None):\n    if order is not None:\n        if not isinstance(order, (list, np.ndarray, pd.Index)):\n            raise ValueError(\"Order must be a list-like object.\")\n        return [category for category in order if category in vector]\n\n    # If no order is provided, determine the unique categories from the vector\n    if isinstance(vector, (pd.Series, pd.Categorical)):\n        unique_categories = vector.dropna().unique()\n    else:\n        unique_categories = pd.Series(vector).dropna().unique()\n\n    return sorted(unique_categories)", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None):\n    if order is not None:\n        if not isinstance(order, (list, np.ndarray, pd.Index)):\n            raise ValueError(\"Order must be a list-like object.\")\n        return [level for level in order if level in vector and pd.notna(level)]\n\n    # If no order is provided, determine the unique levels from the vector\n    if isinstance(vector, (pd.Series, pd.Categorical)):\n        unique_levels = vector.dropna().unique()\n    else:\n        unique_levels = pd.Series(vector).dropna().unique()\n\n    return sorted(unique_levels, key=lambda x: (x is None, x))", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None):\n    if order is not None:\n        if not isinstance(order, (list, np.ndarray, pd.Index)):\n            raise ValueError(\"Order must be a list-like object.\")\n        return [level for level in order if level in vector and pd.notna(level)]\n\n    # If no order is provided, determine the unique levels from the vector\n    if isinstance(vector, (pd.Series, pd.Categorical)):\n        unique_levels = vector.dropna().unique()\n    else:\n        unique_levels = pd.Series(vector).dropna().unique()\n\n    return sorted(unique_levels, key=lambda x: (x is None, x))", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None):\n    if order is not None:\n        if not isinstance(order, (list, np.ndarray, pd.Index)):\n            raise ValueError(\"Order must be a list-like object.\")\n        return [level for level in order if level in vector and pd.notna(level)]\n\n    # If no order is provided, determine the unique levels from the vector\n    if isinstance(vector, (pd.Series, pd.Categorical)):\n        unique_levels = vector.dropna().unique()\n    else:\n        unique_levels = pd.Series(vector).dropna().unique()\n\n    return sorted(unique_levels, key=lambda x: (pd.isna(x), x))", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_categorical_order(self):\n        x = ['a', 'c', 'c', 'b', 'a', 'd']\n        y = [3, 2, 5, 1, 4]\n        order = ['a', 'b', 'c', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(x, order)\n        assert out == order\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        out = categorical_order(np.array(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(pd.Series(x))\n        assert out == ['a', 'c', 'b', 'd']\n        out = categorical_order(y)\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(np.array(y))\n        assert out == [1, 2, 3, 4, 5]\n        out = categorical_order(pd.Series(y))\n        assert out == [1, 2, 3, 4, 5]\n        x = pd.Categorical(x, order)\n        out = categorical_order(x)\n        assert out == list(x.categories)\n        x = pd.Series(x)\n        out = categorical_order(x)\n        assert out == list(x.cat.categories)\n        out = categorical_order(x, ['b', 'a'])\n        assert out == ['b', 'a']\n        x = ['a', np.nan, 'c', 'c', 'b', 'a', 'd']\n        out = categorical_order(x)\n        assert out == ['a', 'c', 'b', 'd']\n    \nTestCoreFunc().test_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef categorical_order(vector, order=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    \n    # Check if data is a DataFrame and extract x, y, and hue\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n    else:\n        x_data = x\n        y_data = y\n        hue_data = hue\n\n    # Handle weights if provided\n    if weights is not None:\n        weights = np.asarray(weights)\n\n    # Determine the bandwidth method\n    if isinstance(bw_method, str):\n        if bw_method == 'scott':\n            bw = np.std(x_data) * len(x_data) ** (-1/5)\n        elif bw_method == 'silverman':\n            bw = np.std(x_data) * (len(x_data) ** (-1/5)) * 1.06\n    else:\n        bw = bw_method\n\n    # Create a grid for evaluation\n    if common_grid:\n        x_min, x_max = np.min(x_data), np.max(x_data)\n        y_min, y_max = np.min(y_data), np.max(y_data)\n        x_grid = np.linspace(x_min - cut * bw, x_max + cut * bw, gridsize)\n        y_grid = np.linspace(y_min - cut * bw, y_max + cut * bw, gridsize)\n    else:\n        x_grid = np.linspace(np.min(x_data), np.max(x_data), gridsize)\n        y_grid = np.linspace(np.min(y_data), np.max(y_data), gridsize)\n\n    # Compute the KDE\n    kde = stats.gaussian_kde(x_data, bw_method=bw)\n    kde_values = kde(x_grid)\n\n    # Plotting\n    if ax is None:\n        ax = plt.gca()\n\n    if fill:\n        ax.fill_between(x_grid, kde_values, alpha=0.5, color=color)\n    else:\n        ax.plot(x_grid, kde_values, color=color)\n\n    if legend:\n        ax.legend()\n\n    if cbar:\n        cbar = plt.colorbar(ax.collections[0], ax=ax, **(cbar_kws or {}))\n    \n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is not None and isinstance(data, pd.DataFrame):\n        if x is not None and isinstance(x, str):\n            x_data = data[x]\n        else:\n            x_data = x\n        \n        if y is not None and isinstance(y, str):\n            y_data = data[y]\n        else:\n            y_data = y\n    else:\n        x_data = x\n        y_data = y\n\n    # Handle weights if provided\n    if weights is not None and data is not None:\n        weights = data[weights] if isinstance(weights, str) else weights\n\n    # Perform kernel density estimation\n    if x_data is not None and y_data is None:\n        # Univariate KDE\n        kde = gaussian_kde(x_data, bw_method=bw_method, weights=weights)\n        x_grid = np.linspace(np.min(x_data) - cut * bw_adjust, \n                             np.max(x_data) + cut * bw_adjust, \n                             gridsize)\n        density = kde(x_grid)\n\n        # Plotting\n        if fill:\n            ax.fill_between(x_grid, density, color=color, alpha=0.5)\n        else:\n            ax.plot(x_grid, density, color=color)\n\n    elif x_data is not None and y_data is not None:\n        # Bivariate KDE\n        kde = gaussian_kde(np.vstack([x_data, y_data]), bw_method=bw_method, weights=weights)\n        x_grid = np.linspace(np.min(x_data) - cut * bw_adjust, \n                             np.max(x_data) + cut * bw_adjust, \n                             gridsize)\n        y_grid = np.linspace(np.min(y_data) - cut * bw_adjust, \n                             np.max(y_data) + cut * bw_adjust, \n                             gridsize)\n        X, Y = np.meshgrid(x_grid, y_grid)\n        positions = np.vstack([X.ravel(), Y.ravel()])\n        density = np.reshape(kde(positions), X.shape)\n\n        # Plotting\n        if fill:\n            ax.contourf(X, Y, density, levels=levels, cmap=palette)\n        else:\n            ax.contour(X, Y, density, levels=levels, cmap=palette)\n\n    # Additional settings\n    if legend:\n        ax.legend()\n    if cbar:\n        plt.colorbar(ax.collections[0], ax=ax, **(cbar_kws or {}))\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is not None:\n        if isinstance(data, pd.DataFrame):\n            if x is not None and x not in data.columns:\n                raise ValueError(f\"x must be a column in the DataFrame, but got {x}\")\n            if y is not None and y not in data.columns:\n                raise ValueError(f\"y must be a column in the DataFrame, but got {y}\")\n        else:\n            data = np.asarray(data)\n\n    # Prepare data for KDE\n    if x is not None and y is None:\n        data_x = data[x] if isinstance(data, pd.DataFrame) else data[:, 0]\n        data_y = None\n    elif y is not None:\n        data_x = data[x] if isinstance(data, pd.DataFrame) else data[:, 0]\n        data_y = data[y] if isinstance(data, pd.DataFrame) else data[:, 1]\n    else:\n        raise ValueError(\"Either x or y must be provided.\")\n\n    # Perform KDE estimation\n    if data_y is None:\n        # Univariate KDE\n        kde = gaussian_kde(data_x, bw_method=bw_method, weights=weights)\n        x_grid = np.linspace(min(data_x) - cut * bw_adjust, max(data_x) + cut * bw_adjust, gridsize)\n        density = kde(x_grid)\n        \n        # Plotting\n        if fill:\n            ax.fill_between(x_grid, density, color=color, alpha=0.5)\n        else:\n            ax.plot(x_grid, density, color=color)\n    else:\n        # Bivariate KDE\n        kde = gaussian_kde(np.vstack([data_x, data_y]), bw_method=bw_method, weights=weights)\n        x_grid = np.linspace(min(data_x) - cut * bw_adjust, max(data_x) + cut * bw_adjust, gridsize)\n        y_grid = np.linspace(min(data_y) - cut * bw_adjust, max(data_y) + cut * bw_adjust, gridsize)\n        X, Y = np.meshgrid(x_grid, y_grid)\n        positions = np.vstack([X.ravel(), Y.ravel()])\n        density = np.reshape(kde(positions).T, X.shape)\n\n        # Plotting\n        if fill:\n            ax.contourf(X, Y, density, levels=levels, cmap=palette)\n        else:\n            ax.contour(X, Y, density, levels=levels, colors=color)\n\n    # Additional plot settings\n    if legend:\n        ax.legend()\n    if cbar:\n        plt.colorbar(ax=ax, **(cbar_kws or {}))\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    \n    # Validate inputs\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    if x is None and y is None:\n        raise ValueError(\"At least one of 'x' or 'y' must be provided.\")\n    \n    # Prepare data\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n    else:\n        x_data = x\n        y_data = y\n    \n    # Handle weights\n    if weights is not None:\n        if len(weights) != len(x_data):\n            raise ValueError(\"Weights must be the same length as the data.\")\n    \n    # Set up the grid for KDE\n    if y is not None:\n        # Bivariate KDE\n        x_min, x_max = np.min(x_data), np.max(x_data)\n        y_min, y_max = np.min(y_data), np.max(y_data)\n        x_grid = np.linspace(x_min - cut * bw_adjust, x_max + cut * bw_adjust, gridsize)\n        y_grid = np.linspace(y_min - cut * bw_adjust, y_max + cut * bw_adjust, gridsize)\n        X, Y = np.meshgrid(x_grid, y_grid)\n        positions = np.vstack([X.ravel(), Y.ravel()]).T\n    else:\n        # Univariate KDE\n        x_min, x_max = np.min(x_data), np.max(x_data)\n        x_grid = np.linspace(x_min - cut * bw_adjust, x_max + cut * bw_adjust, gridsize)\n        positions = x_grid[:, np.newaxis]\n    \n    # Compute the KDE\n    from scipy.stats import gaussian_kde\n    kde = gaussian_kde(x_data, bw_method=bw_method)\n    density = kde(positions.T)\n    \n    # Reshape density for plotting\n    if y is not None:\n        density = density.reshape(X.shape)\n    \n    # Plotting\n    if ax is None:\n        ax = plt.gca()\n    \n    if y is not None:\n        # Bivariate plot\n        if fill:\n            ax.contourf(X, Y, density, levels=levels, cmap=palette)\n        else:\n            ax.contour(X, Y, density, levels=levels, colors=color)\n    else:\n        # Univariate plot\n        if fill:\n            ax.fill_between(x_grid, density, color=color)\n        else:\n            ax.plot(x_grid, density, color=color)\n    \n    # Additional settings\n    if legend:\n        ax.legend()\n    if cbar:\n        cbar = plt.colorbar(ax.collections[0], ax=ax, cax=cbar_ax, **(cbar_kws or {}))\n    \n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "kdeplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    # Prepare data for KDE\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n    else:\n        x_data = data[:, 0] if x is None else x\n        y_data = data[:, 1] if y is None else y\n\n    # Handle weights\n    if weights is not None:\n        if len(weights) != len(x_data):\n            raise ValueError(\"Weights must be the same length as the data.\")\n    \n    # Set up the grid for KDE\n    x_min, x_max = np.min(x_data), np.max(x_data)\n    y_min, y_max = np.min(y_data), np.max(y_data)\n    \n    x_grid = np.linspace(x_min - cut * bw_adjust, x_max + cut * bw_adjust, gridsize)\n    y_grid = np.linspace(y_min - cut * bw_adjust, y_max + cut * bw_adjust, gridsize)\n    \n    # Compute the KDE\n    kde = stats.gaussian_kde([x_data, y_data], weights=weights, bw_method=bw_method)\n    Z = kde(np.vstack([x_grid, y_grid]))\n    \n    # Create the plot\n    if ax is None:\n        ax = plt.gca()\n    \n    if fill:\n        ax.contourf(x_grid, y_grid, Z.reshape(len(x_grid), len(y_grid)), levels=levels, cmap=palette)\n    else:\n        ax.contour(x_grid, y_grid, Z.reshape(len(x_grid), len(y_grid)), levels=levels, colors=color)\n\n    # Set limits and labels\n    if clip is not None:\n        ax.set_xlim(clip[0])\n        ax.set_ylim(clip[1])\n    \n    if legend:\n        ax.legend()\n    \n    if cbar:\n        cbar = plt.colorbar(ax.collections[0], ax=ax, cax=cbar_ax, **(cbar_kws or {}))\n    \n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = kdeplot(x=[])\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotUnivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestKDEPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        x = [1, 2]\n        weights = [2, 1]\n        ax = kdeplot(x=x, weights=weights, bw_method=0.1)\n        xdata, ydata = ax.lines[0].get_xydata().T\n        y1 = ydata[np.abs(xdata - 1).argmin()]\n        y2 = ydata[np.abs(xdata - 2).argmin()]\n        assert y1 == pytest.approx(2 * y2)\n    \nTestKDEPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\n\nclass TestKDEPlotBivariate():\n    def test_singular_data(self):\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=np.ones(10), y=np.arange(10))\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = dist.kdeplot(x=[5], y=[6])\n        assert not ax.lines\n        with pytest.warns(UserWarning):\n            ax = kdeplot(x=[1929245168.06679] * 18, y=np.arange(18))\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error', UserWarning)\n            ax = kdeplot(x=[5], y=[7], warn_singular=False)\n        assert not ax.lines\n    \nTestKDEPlotBivariate().test_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef kdeplot(data=None, *, x=None, y=None, hue=None, weights=None, palette=\n    None, hue_order=None, hue_norm=None, color=None, fill=None, multiple=\n    'layer', common_norm=True, common_grid=False, cumulative=False,\n    bw_method='scott', bw_adjust=1, warn_singular=True, log_scale=None,\n    levels=10, thresh=0.05, gridsize=200, cut=3, clip=None, legend=True,\n    cbar=False, cbar_ax=None, cbar_kws=None, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a light color palette that blends from a light color to a specified base color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        Whether to reverse the direction of the color blend. Default is False.\n    as_cmap : bool, optional\n        Whether to return the palette as a matplotlib ListedColormap. Default is False.\n    input : str, optional\n        Specifies the color space to interpret the input color. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    light_color = tuple(min(1, c + 0.5) for c in base_color)  # Create a light version of the base color\n    colors = [light_color, base_color]\n    \n    if reverse:\n        colors.reverse()\n    \n    return blend_palette(colors, n_colors, as_cmap, input)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a sequential color palette that blends from a light color to a specified base color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette (default is 6).\n    reverse : bool, optional\n        Whether to reverse the direction of the color blend (default is False).\n    as_cmap : bool, optional\n        Whether to return the palette as a matplotlib ListedColormap (default is False).\n    input : str, optional\n        The color space to interpret the input color (default is 'rgb').\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    light_color = tuple(min(1, c + 0.5) for c in base_color)  # Create a lighter version of the base color\n    colors = [light_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=as_cmap)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a sequential color palette that blends from a light color to a specified base color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        Whether to reverse the direction of the color blend. Default is False.\n    as_cmap : bool, optional\n        Whether to return the palette as a matplotlib ListedColormap. Default is False.\n    input : str, optional\n        Color space to interpret the input color. Valid options are 'rgb', 'hls', 'husl', 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    light_color = tuple(min(1, c + 0.5) for c in base_color)  # Create a light version of the base color\n    colors = [light_color, base_color]\n    \n    if reverse:\n        colors.reverse()\n    \n    return blend_palette(colors, n_colors=n_colors, as_cmap=as_cmap)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a light color palette that blends from a light color to a specified base color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        Whether to reverse the direction of the color blend. Default is False.\n    as_cmap : bool, optional\n        Whether to return the palette as a matplotlib ListedColormap. Default is False.\n    input : str, optional\n        Specifies the color space to interpret the input color. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    light_color = tuple(min(1, c + 0.5) for c in base_color)  # Create a light version of the base color\n    colors = [light_color, base_color]\n    \n    if reverse:\n        colors.reverse()\n    \n    return blend_palette(colors, n_colors=n_colors, as_cmap=as_cmap)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "light_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a light color palette that blends from a light color to a specified base color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        Whether to reverse the direction of the color blend. Default is False.\n    as_cmap : bool, optional\n        Whether to return the palette as a matplotlib ListedColormap. Default is False.\n    input : str, optional\n        The color space to interpret the input color. Valid options are 'rgb', 'hls', 'husl', 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    light_color = tuple(min(1, c + 0.5) for c in base_color)  # Create a light version of the base color\n    colors = [light_color, base_color]\n    \n    if reverse:\n        colors.reverse()\n    \n    return blend_palette(colors, n_colors=n_colors, as_cmap=as_cmap)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_light_palette(self):\n        n = 4\n        pal_forward = light_palette('red', n)\n        pal_reverse = light_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('light:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('light:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = light_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('light:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = light_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('light:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_light_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_diverging_palette(self):\n        h_neg, h_pos = 100, 200\n        sat, lum = 70, 50\n        args = h_neg, h_pos, sat, lum\n        n = 12\n        pal = palettes.diverging_palette(*args, n=n)\n        neg_pal = light_palette((h_neg, sat, lum), int(n // 2), input=\n            'husl')\n        pos_pal = light_palette((h_pos, sat, lum), int(n // 2), input=\n            'husl')\n        assert len(pal) == n\n        assert pal[0] == neg_pal[-1]\n        assert pal[-1] == pos_pal[-1]\n        pal_dark = palettes.diverging_palette(*args, n=n, center='dark')\n        assert np.mean(pal[int(n / 2)]) > np.mean(pal_dark[int(n / 2)])\n        pal_cmap = palettes.diverging_palette(*args, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n    \nTestColorPalettes().test_diverging_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef light_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "histplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    \n    # Prepare data\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n    else:\n        x_data = data if x is not None else None\n        y_data = data if y is not None else None\n        hue_data = None\n\n    # Handle weights\n    if weights is not None:\n        weights = np.asarray(weights)\n\n    # Determine bins\n    if bins == 'auto':\n        bins = 'auto'  # Placeholder for actual bin calculation logic\n\n    # Create histogram\n    if ax is None:\n        ax = plt.gca()\n\n    if y is None:  # Univariate\n        counts, bin_edges = np.histogram(x_data, bins=bins, range=binrange, weights=weights)\n        ax.hist(x_data, bins=bins, weights=weights, color=color, alpha=0.7, edgecolor='black', linewidth=1)\n    else:  # Bivariate\n        hist, xedges, yedges = np.histogram2d(x_data, y_data, bins=bins, range=binrange, weights=weights)\n        ax.imshow(hist.T, origin='lower', aspect='auto', extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]], cmap='Blues')\n\n    # KDE plot\n    if kde:\n        if kde_kws is None:\n            kde_kws = {}\n        # Placeholder for actual KDE implementation\n        # ax.plot(kde_x, kde_y, **line_kws)\n\n    # Log scale\n    if log_scale:\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n\n    # Legend\n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "histplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    if ax is None:\n        ax = plt.gca()\n    \n    # Prepare data for plotting\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n    else:\n        x_data = data if x is not None else None\n        y_data = data if y is not None else None\n        hue_data = None\n    \n    # Create histogram\n    if y is None:  # Univariate histogram\n        counts, bins = np.histogram(x_data, bins=bins, range=binrange, weights=weights)\n        if cumulative:\n            counts = np.cumsum(counts)\n        \n        if fill:\n            ax.bar(bins[:-1], counts, width=np.diff(bins), align='edge', alpha=0.5, color=color)\n        else:\n            ax.step(bins[:-1], counts, where='post', color=color)\n    \n    else:  # Bivariate histogram\n        if common_bins:\n            # Create common bins for both x and y\n            x_bins = np.histogram_bin_edges(x_data, bins=bins, range=binrange)\n            y_bins = np.histogram_bin_edges(y_data, bins=bins, range=binrange)\n            hist, x_edges, y_edges = np.histogram2d(x_data, y_data, bins=[x_bins, y_bins], weights=weights)\n            extent = [x_edges[0], x_edges[-1], y_edges[0], y_edges[-1]]\n            if fill:\n                ax.imshow(hist.T, extent=extent, origin='lower', aspect='auto', cmap='Blues', alpha=0.5)\n            else:\n                ax.contourf(x_edges[:-1], y_edges[:-1], hist.T, levels=10, cmap='Blues')\n    \n    # KDE plot if requested\n    if kde:\n        from scipy.stats import gaussian_kde\n        if y is None:\n            kde_data = gaussian_kde(x_data, bw_method=kde_kws.get('bw_method', 'scott'))\n            x_range = np.linspace(min(x_data), max(x_data), 100)\n            ax.plot(x_range, kde_data(x_range), **(line_kws if line_kws else {}))\n        else:\n            # Bivariate KDE\n            kde_data = gaussian_kde(np.vstack([x_data, y_data]), bw_method=kde_kws.get('bw_method', 'scott'))\n            x_range = np.linspace(min(x_data), max(x_data), 100)\n            y_range = np.linspace(min(y_data), max(y_data), 100)\n            X, Y = np.meshgrid(x_range, y_range)\n            Z = kde_data(np.vstack([X.ravel(), Y.ravel()])).reshape(X.shape)\n            ax.contour(X, Y, Z, levels=10, cmap='Reds')\n    \n    # Additional customization\n    if legend:\n        ax.legend()\n    if log_scale:\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n    \n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "histplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    if ax is None:\n        ax = plt.gca()\n\n    # Handle data selection based on x and y\n    if x is not None and y is not None:\n        data_x = data[x]\n        data_y = data[y]\n    elif x is not None:\n        data_x = data[x]\n        data_y = None\n    elif y is not None:\n        data_x = None\n        data_y = data[y]\n    else:\n        raise ValueError(\"At least one of 'x' or 'y' must be provided.\")\n\n    # Determine bins\n    if bins is None:\n        bins = 'auto'\n    \n    # Create histogram\n    if data_y is not None:\n        # Bivariate histogram\n        hist, xedges, yedges = np.histogram2d(data_x, data_y, bins=bins, range=binrange)\n        if cumulative:\n            hist = np.cumsum(hist, axis=0)\n        \n        # Plotting\n        c = ax.pcolormesh(xedges, yedges, hist.T, shading='auto', **kwargs)\n        if cbar:\n            cbar = plt.colorbar(c, ax=ax, **(cbar_kws or {}))\n    else:\n        # Univariate histogram\n        hist, edges = np.histogram(data_x, bins=bins, range=binrange)\n        if cumulative:\n            hist = np.cumsum(hist)\n        \n        if element == 'bars':\n            ax.bar(edges[:-1], hist, width=np.diff(edges), align='edge', **kwargs)\n        elif element == 'step':\n            ax.step(edges[:-1], hist, where='post', **kwargs)\n        elif element == 'fill':\n            ax.fill_between(edges[:-1], hist, **kwargs)\n\n    # KDE plot if requested\n    if kde:\n        from scipy.stats import gaussian_kde\n        kde_data = gaussian_kde(data_x)\n        x_range = np.linspace(min(data_x), max(data_x), 100)\n        ax.plot(x_range, kde_data(x_range), **(line_kws or {}))\n\n    # Additional customization\n    if log_scale:\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n    \n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "histplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    # Prepare the axes\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle univariate and bivariate cases\n    if y is None:\n        # Univariate histogram\n        if discrete is None:\n            discrete = pd.api.types.is_integer_dtype(data[x])\n        \n        # Create histogram\n        hist_data = data[x]\n        if weights is not None:\n            weights = data[weights]\n        \n        # Plot histogram\n        ax.hist(hist_data, bins=bins, weights=weights, density=(stat == 'density'), \n                cumulative=cumulative, color=color, alpha=0.7, edgecolor='black')\n        \n        if kde:\n            from scipy.stats import gaussian_kde\n            kde_data = gaussian_kde(hist_data)\n            x_range = np.linspace(hist_data.min(), hist_data.max(), 100)\n            ax.plot(x_range, kde_data(x_range), **(kde_kws if kde_kws else {}))\n    \n    else:\n        # Bivariate histogram\n        hist_data_x = data[x]\n        hist_data_y = data[y]\n        \n        if weights is not None:\n            weights = data[weights]\n        \n        # Create 2D histogram\n        hist, xedges, yedges = np.histogram2d(hist_data_x, hist_data_y, bins=bins, \n                                               range=binrange, weights=weights)\n        \n        # Normalize if required\n        if common_norm:\n            hist = hist / hist.sum()\n        \n        # Create a meshgrid for plotting\n        xpos, ypos = np.meshgrid(xedges[:-1], yedges[:-1], indexing=\"ij\")\n        xpos = xpos.ravel()\n        ypos = ypos.ravel()\n        zpos = np.zeros_like(xpos)\n        \n        # Construct arrays with the dimensions for the bars\n        dx = dy = np.ones_like(zpos)\n        dz = hist.ravel()\n        \n        # Create the bars\n        ax.bar3d(xpos, ypos, zpos, dx, dy, dz, zsort='average', color=color, alpha=0.7)\n        \n        if cbar:\n            if cbar_ax is None:\n                cbar_ax = plt.gca().add_axes([0.91, 0.1, 0.03, 0.8])  # Adjust as needed\n            cbar = plt.colorbar(ax.collections[0], cax=cbar_ax, **(cbar_kws if cbar_kws else {}))\n    \n    # Set log scale if required\n    if log_scale:\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n    \n    # Add legend if required\n    if legend:\n        ax.legend()\n    \n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "histplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs):\n    \n    # Prepare the data\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            x_data = data[x]\n        if y is not None:\n            y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n    else:\n        x_data = data if x is not None else None\n        y_data = data if y is not None else None\n        hue_data = None\n\n    # Handle weights\n    if weights is not None:\n        weights = np.asarray(weights)\n\n    # Determine bins\n    if bins == 'auto':\n        bins = 'auto'  # This can be replaced with a more specific binning strategy if needed\n\n    # Create histogram\n    if y is None:  # Univariate histogram\n        counts, bin_edges = np.histogram(x_data, bins=bins, range=binrange, weights=weights)\n        if cumulative:\n            counts = np.cumsum(counts)\n        if fill:\n            ax.bar(bin_edges[:-1], counts, width=np.diff(bin_edges), align='edge', alpha=0.5)\n        else:\n            ax.step(bin_edges[:-1], counts, where='post')\n    else:  # Bivariate histogram\n        hist, xedges, yedges = np.histogram2d(x_data, y_data, bins=bins, range=binrange, weights=weights)\n        if cumulative:\n            hist = np.cumsum(hist, axis=0)\n        if common_bins:\n            # Handle common bins logic\n            pass\n        if fill:\n            ax.imshow(hist.T, origin='lower', aspect='auto', extent=[xedges[0], xedges[-1], yedges[0], yedges[-1]], **kwargs)\n\n    # KDE plot\n    if kde:\n        from scipy.stats import gaussian_kde\n        kde_data = gaussian_kde(x_data, **(kde_kws if kde_kws else {}))\n        x_kde = np.linspace(min(x_data), max(x_data), 100)\n        ax.plot(x_kde, kde_data(x_kde), **(line_kws if line_kws else {}))\n\n    # Log scale\n    if log_scale:\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n\n    # Legend\n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_empty_data(self):\n        ax = histplot(x=[])\n        assert not ax.patches\n    \nTestHistPlotUnivariate().test_empty_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_kde_singular_data(self):\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=np.ones(10), kde=True)\n        assert not ax.lines\n        with warnings.catch_warnings():\n            warnings.simplefilter('error')\n            ax = histplot(x=[5], kde=True)\n        assert not ax.lines\n    \nTestHistPlotUnivariate().test_kde_singular_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}, {"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestHistPlotUnivariate(SharedAxesLevelTests):\n    def test_weighted_histogram(self):\n        ax = histplot(x=[0, 1, 2], weights=[1, 2, 3], discrete=True)\n        bar_heights = [b.get_height() for b in ax.patches]\n        assert bar_heights == [1, 2, 3]\n    \nTestHistPlotUnivariate().test_weighted_histogram()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef histplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'count', bins='auto', binwidth=None, binrange=None, discrete=None,\n    cumulative=False, common_bins=True, common_norm=True, multiple='layer',\n    element='bars', fill=True, shrink=1, kde=False, kde_kws=None, line_kws=\n    None, thresh=0, pthresh=None, pmax=None, cbar=False, cbar_ax=None,\n    cbar_kws=None, palette=None, hue_order=None, hue_norm=None, color=None,\n    log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n    \n    # Prepare data\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            data = data[x]\n        elif y is not None:\n            data = data[y]\n        else:\n            raise ValueError(\"Either x or y must be specified.\")\n    elif isinstance(data, dict):\n        if x is not None:\n            data = data[x]\n        elif y is not None:\n            data = data[y]\n        else:\n            raise ValueError(\"Either x or y must be specified.\")\n    \n    if hue is not None:\n        if isinstance(data, pd.DataFrame):\n            hue_data = data[hue]\n        else:\n            raise ValueError(\"hue must be a column in the DataFrame.\")\n    else:\n        hue_data = None\n\n    # Calculate ECDF\n    if weights is not None:\n        weights = np.asarray(weights)\n        data = np.asarray(data)\n        sorted_data = np.sort(data)\n        cumulative_weights = np.cumsum(weights[np.argsort(data)])\n        total_weight = cumulative_weights[-1]\n        ecdf = cumulative_weights / total_weight\n    else:\n        sorted_data = np.sort(data)\n        ecdf = np.arange(1, len(sorted_data) + 1) / len(sorted_data)\n\n    if complementary:\n        ecdf = 1 - ecdf\n\n    # Plotting\n    if hue_data is not None:\n        unique_hues = np.unique(hue_data)\n        for hue_value in unique_hues:\n            mask = (hue_data == hue_value)\n            ax.step(sorted_data[mask], ecdf[mask], where='post', label=hue_value, **kwargs)\n    else:\n        ax.step(sorted_data, ecdf, where='post', **kwargs)\n\n    # Set log scale if specified\n    if log_scale:\n        ax.set_xscale('log')\n    \n    # Set labels and title\n    ax.set_xlabel(x if x is not None else 'Data')\n    ax.set_ylabel('ECDF')\n    if legend:\n        ax.legend(title=hue)\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n\n    if isinstance(data, dict):\n        data = pd.DataFrame(data)\n\n    if x is not None:\n        x_data = data[x]\n    elif y is not None:\n        x_data = data[y]\n    else:\n        raise ValueError(\"Either 'x' or 'y' must be provided.\")\n\n    if weights is not None:\n        weights = data[weights]\n\n    # Calculate ECDF\n    sorted_data = np.sort(x_data)\n    n = len(sorted_data)\n    if weights is not None:\n        cumulative_weights = np.cumsum(weights[sorted_data.argsort()])\n        ecdf_values = cumulative_weights / cumulative_weights[-1]\n    else:\n        ecdf_values = np.arange(1, n + 1) / n\n\n    if complementary:\n        ecdf_values = 1 - ecdf_values\n\n    # Plotting\n    if hue is not None:\n        unique_hues = data[hue].unique()\n        if hue_order is not None:\n            unique_hues = [h for h in hue_order if h in unique_hues]\n        for hue_value in unique_hues:\n            subset = data[data[hue] == hue_value]\n            subset_sorted = np.sort(subset[x] if x is not None else subset[y])\n            subset_n = len(subset_sorted)\n            if weights is not None:\n                subset_weights = subset[weights]\n                subset_cumulative_weights = np.cumsum(subset_weights[subset_sorted.argsort()])\n                subset_ecdf_values = subset_cumulative_weights / subset_cumulative_weights[-1]\n            else:\n                subset_ecdf_values = np.arange(1, subset_n + 1) / subset_n\n\n            if complementary:\n                subset_ecdf_values = 1 - subset_ecdf_values\n\n            ax.step(subset_sorted, subset_ecdf_values, where='post', label=hue_value, **kwargs)\n    else:\n        ax.step(sorted_data, ecdf_values, where='post', **kwargs)\n\n    # Log scale\n    if log_scale:\n        ax.set_xscale('log')\n\n    # Legend\n    if legend:\n        ax.legend()\n\n    ax.set_xlabel(x if x is not None else y)\n    ax.set_ylabel('ECDF')\n    ax.set_title('Empirical Cumulative Distribution Function')\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n\n    if isinstance(data, dict):\n        data = pd.DataFrame(data)\n\n    if x is not None:\n        data = data[x]\n    elif y is not None:\n        data = data[y]\n    else:\n        raise ValueError(\"Either 'x' or 'y' must be provided.\")\n\n    if weights is not None:\n        weights = np.asarray(weights)\n        if len(weights) != len(data):\n            raise ValueError(\"Weights must be the same length as data.\")\n\n    data = np.asarray(data)\n    if complementary:\n        data = 1 - data\n\n    # Calculate ECDF\n    sorted_data = np.sort(data)\n    y_values = np.arange(1, len(sorted_data) + 1) / len(sorted_data)\n\n    if stat == 'count':\n        y_values = np.arange(1, len(sorted_data) + 1)\n\n    if log_scale:\n        ax.set_xscale('log')\n\n    ax.step(sorted_data, y_values, where='post', **kwargs)\n\n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n\n    # Prepare data\n    if isinstance(data, pd.DataFrame):\n        if x is not None:\n            data = data[x]\n        elif y is not None:\n            data = data[y]\n    elif isinstance(data, dict):\n        data = data[x] if x else data[y]\n\n    if weights is not None:\n        weights = np.asarray(weights)\n    \n    # Calculate ECDF\n    data = np.asarray(data)\n    if weights is not None:\n        sorted_indices = np.argsort(data)\n        data = data[sorted_indices]\n        weights = weights[sorted_indices]\n        cumulative_weights = np.cumsum(weights)\n        total_weight = cumulative_weights[-1]\n        ecdf = cumulative_weights / total_weight\n    else:\n        sorted_data = np.sort(data)\n        ecdf = np.arange(1, len(sorted_data) + 1) / len(sorted_data)\n\n    if complementary:\n        ecdf = 1 - ecdf\n\n    # Plotting\n    if stat == 'count':\n        if weights is not None:\n            ax.step(data, cumulative_weights, where='post', **kwargs)\n        else:\n            ax.step(data, np.arange(1, len(data) + 1), where='post', **kwargs)\n    else:\n        ax.step(data, ecdf, where='post', **kwargs)\n\n    if log_scale:\n        ax.set_xscale('log')\n\n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ecdfplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/distributions.py", "response": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs):\n    \n    if ax is None:\n        ax = plt.gca()\n\n    if isinstance(data, dict):\n        data = pd.DataFrame(data)\n\n    if x is not None:\n        values = data[x]\n    elif y is not None:\n        values = data[y]\n    else:\n        raise ValueError(\"Either 'x' or 'y' must be provided.\")\n\n    if weights is not None:\n        weights = data[weights]\n\n    # Calculate ECDF\n    sorted_values = np.sort(values)\n    n = len(sorted_values)\n    if weights is not None:\n        cumulative_weights = np.cumsum(np.sort(weights))\n        ecdf = cumulative_weights / cumulative_weights[-1]\n    else:\n        ecdf = np.arange(1, n + 1) / n\n\n    if complementary:\n        ecdf = 1 - ecdf\n\n    # Plotting\n    if hue is not None:\n        unique_hues = data[hue].unique()\n        if hue_order is not None:\n            unique_hues = hue_order\n        for hue_value in unique_hues:\n            hue_mask = data[hue] == hue_value\n            ax.step(sorted_values[hue_mask], ecdf[hue_mask], label=hue_value, **kwargs)\n    else:\n        ax.step(sorted_values, ecdf, **kwargs)\n\n    ax.set_xlabel(x if x is not None else y)\n    ax.set_ylabel(stat.capitalize())\n    \n    if log_scale:\n        ax.set_xscale('log')\n    \n    if legend:\n        ax.legend()\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import distributions as dist\nfrom seaborn.palettes import color_palette\nfrom seaborn.palettes import light_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import _no_scipy\nfrom seaborn.distributions import _DistributionPlotter\nfrom seaborn.distributions import displot\nfrom seaborn.distributions import distplot\nfrom seaborn.distributions import histplot\nfrom seaborn.distributions import ecdfplot\nfrom seaborn.distributions import kdeplot\nfrom seaborn.distributions import rugplot\nfrom seaborn.utils import _version_predates\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn._testing import assert_legends_equal\nfrom seaborn._testing import assert_colors_equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df, **kwargs):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C0',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        self.func(data=long_df, x='y', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C1',\n            check_alpha=False)\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='y', color='C2', ax=ax, **kwargs)\n        assert_colors_equal(self.get_last_color(ax, **kwargs), 'C2',\n            check_alpha=False)\n\nclass TestECDFPlotUnivariate(SharedAxesLevelTests):\n    def test_weights(self):\n        ax = ecdfplot(x=[1, 2, 3], weights=[1, 1, 2])\n        y = ax.lines[0].get_ydata()\n        assert_array_equal(y, [0, 0.25, 0.5, 1])\n    \nTestECDFPlotUnivariate().test_weights()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_distributions.py"}], "method_code_mask": "from numbers import Number\nfrom functools import partial\nimport math\nimport textwrap\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.transforms as tx\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.colors import to_rgba\nfrom matplotlib.collections import LineCollection\n\n\ndef ecdfplot(data=None, *, x=None, y=None, hue=None, weights=None, stat=\n    'proportion', complementary=False, palette=None, hue_order=None,\n    hue_norm=None, log_scale=None, legend=True, ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights):\n    lower_limits = cis[0]\n    upper_limits = cis[1]\n    \n    # Calculate the error sizes relative to the heights\n    errsize_lower = heights - lower_limits\n    errsize_upper = upper_limits - heights\n    \n    # Combine the error sizes into a 2 x n array\n    errsize = np.array([errsize_lower, errsize_upper])\n    \n    return errsize", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights):\n    lower_limits = cis[0]\n    upper_limits = cis[1]\n    \n    # Calculate the error sizes relative to the heights\n    errsize_lower = heights - lower_limits\n    errsize_upper = upper_limits - heights\n    \n    return np.array([errsize_lower, errsize_upper])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights):\n    lower_limits = cis[0]\n    upper_limits = cis[1]\n    \n    # Calculate the error sizes relative to the heights\n    errsize_lower = heights - lower_limits\n    errsize_upper = upper_limits - heights\n    \n    return np.array([errsize_lower, errsize_upper])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights):\n    lower_limits = cis[0]\n    upper_limits = cis[1]\n    \n    # Calculate the error sizes relative to the heights\n    errsize_lower = heights - lower_limits\n    errsize_upper = upper_limits - heights\n    \n    return np.array([errsize_lower, errsize_upper])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "ci_to_errsize", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights):\n    lower_limits = cis[0]\n    upper_limits = cis[1]\n    \n    # Calculate the error sizes relative to the heights\n    errsize_lower = heights - lower_limits\n    errsize_upper = upper_limits - heights\n    \n    return np.array([errsize_lower, errsize_upper])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ci_to_errsize():\n    \"\"\"Test behavior of ci_to_errsize.\"\"\"\n    cis = [[0.5, 0.5], [1.25, 1.5]]\n    heights = [1, 1.5]\n    actual_errsize = np.array([[0.5, 1], [0.25, 0]])\n    test_errsize = ci_to_errsize(cis, heights)\n    assert_array_equal(actual_errsize, test_errsize)\n\ntest_ci_to_errsize()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef ci_to_errsize(cis, heights): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop):\n    # Convert the input color to RGB format\n    if isinstance(color, str):\n        # If the color is a hex code or HTML color name, convert it to RGB\n        rgb = to_rgb(color)\n    elif isinstance(color, tuple) and len(color) == 3:\n        # If the color is an RGB tuple, ensure it's in the range [0, 1]\n        rgb = tuple(c / 255.0 for c in color)\n    else:\n        raise ValueError(\"Invalid color format. Must be hex, RGB tuple, or HTML color name.\")\n\n    # Convert RGB to HLS\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n\n    # Desaturate the color\n    new_s = s * prop\n\n    # Convert back to RGB\n    new_rgb = colorsys.hls_to_rgb(h, l, new_s)\n\n    # Convert RGB back to 0-255 range\n    new_color = tuple(int(c * 255) for c in new_rgb)\n\n    return new_color", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop):\n    # Convert color to RGB if it's in hex or HTML name\n    if isinstance(color, str):\n        color = to_rgb(color)  # Convert hex or name to RGB tuple\n    elif isinstance(color, tuple) and len(color) == 3:\n        color = color  # Already an RGB tuple\n    else:\n        raise ValueError(\"Invalid color format. Must be hex, RGB tuple, or HTML color name.\")\n\n    # Convert RGB to HLS\n    r, g, b = color\n    h, l, s = colorsys.rgb_to_hls(r, g, b)\n\n    # Desaturate the color\n    s *= prop  # Reduce saturation by the given proportion\n\n    # Convert back to RGB\n    r, g, b = colorsys.hls_to_rgb(h, l, s)\n\n    # Return the new color as a tuple\n    return (r, g, b)", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop):\n    # Convert the input color to RGB format\n    if isinstance(color, str):\n        # If the color is a hex code or HTML color name, convert it to RGB\n        rgb = to_rgb(color)\n    elif isinstance(color, tuple) and len(color) == 3:\n        # If the color is an RGB tuple, ensure it's in the range [0, 1]\n        rgb = tuple(c / 255.0 for c in color)\n    else:\n        raise ValueError(\"Invalid color format. Provide a hex code, RGB tuple, or HTML color name.\")\n\n    # Convert RGB to HLS\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n\n    # Desaturate the color\n    new_s = s * prop\n\n    # Convert back to RGB\n    new_rgb = colorsys.hls_to_rgb(h, l, new_s)\n\n    # Convert RGB back to 0-255 range\n    new_color = tuple(int(c * 255) for c in new_rgb)\n\n    return new_color", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop):\n    # Convert color to RGB if it is in hex or name format\n    if isinstance(color, str):\n        color = to_rgb(color)  # Convert hex or name to RGB tuple\n\n    # Ensure color is in the range [0, 1]\n    color = np.clip(color, 0, 1)\n\n    # Convert RGB to HLS\n    h, l, s = colorsys.rgb_to_hls(*color)\n\n    # Desaturate the color\n    s *= prop\n\n    # Convert back to RGB\n    new_color = colorsys.hls_to_rgb(h, l, s)\n\n    return new_color", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "desaturate", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop):\n    # Convert the input color to RGB format\n    if isinstance(color, str):\n        # If the color is a hex code or HTML color name, convert it to RGB\n        rgb = to_rgb(color)\n    elif isinstance(color, tuple) and len(color) == 3:\n        # If the color is an RGB tuple, use it directly\n        rgb = color\n    else:\n        raise ValueError(\"Invalid color format. Must be hex, RGB tuple, or HTML color name.\")\n\n    # Convert RGB to HLS\n    h, l, s = colorsys.rgb_to_hls(*rgb)\n\n    # Desaturate the color\n    new_s = s * prop\n\n    # Convert back to RGB\n    new_rgb = colorsys.hls_to_rgb(h, l, new_s)\n\n    return new_rgb", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_desaturate():\n    \"\"\"Test color desaturation.\"\"\"\n    out1 = desaturate('red', 0.5)\n    assert out1 == (0.75, 0.25, 0.25)\n    out2 = desaturate('#00FF00', 0.5)\n    assert out2 == (0.25, 0.75, 0.25)\n    out3 = desaturate((0, 0, 1), 0.5)\n    assert out3 == (0.25, 0.25, 0.75)\n    out4 = desaturate('red', 0.5)\n    assert out4 == (0.75, 0.25, 0.25)\n    out5 = desaturate('lightblue', 1)\n    assert out5 == mpl.colors.to_rgb('lightblue')\n\ntest_desaturate()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = palettes.husl_palette(6)\n        pal1 = [desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef desaturate(color, prop): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Determine if the x and y ticklabels on a given matplotlib Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.\n    \"\"\"\n    x_labels = ax.get_xticklabels()\n    y_labels = ax.get_yticklabels()\n    \n    x_overlap = axis_ticklabels_overlap(x_labels)\n    y_overlap = axis_ticklabels_overlap(y_labels)\n    \n    return x_overlap, y_overlap", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Determine if the x and y ticklabels on a given matplotlib Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.\n    \"\"\"\n    x_labels = ax.get_xticklabels()\n    y_labels = ax.get_yticklabels()\n    \n    x_overlap = axis_ticklabels_overlap(x_labels)\n    y_overlap = axis_ticklabels_overlap(y_labels)\n    \n    return x_overlap, y_overlap", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Determine if the x and y ticklabels on a given matplotlib Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.\n    \"\"\"\n    x_labels = ax.get_xticklabels()\n    y_labels = ax.get_yticklabels()\n    \n    x_overlap = axis_ticklabels_overlap(x_labels)\n    y_overlap = axis_ticklabels_overlap(y_labels)\n    \n    return x_overlap, y_overlap", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Determine if the x and y ticklabels on a given matplotlib Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.\n    \"\"\"\n    x_labels = ax.get_xticklabels()\n    y_labels = ax.get_yticklabels()\n    \n    x_overlap = axis_ticklabels_overlap(x_labels)\n    y_overlap = axis_ticklabels_overlap(y_labels)\n    \n    return x_overlap, y_overlap", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axes_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax):\n    \"\"\"Determine if the x and y ticklabels on a given matplotlib Axes overlap.\n\n    Parameters\n    ----------\n    ax : matplotlib Axes\n        The axes to check for overlapping ticklabels.\n\n    Returns\n    -------\n    x_overlap, y_overlap : booleans\n        x_overlap is True if the x ticklabels overlap, otherwise False.\n        y_overlap is True if the y ticklabels overlap, otherwise False.\n    \"\"\"\n    x_labels = ax.get_xticklabels()\n    y_labels = ax.get_yticklabels()\n    \n    x_overlap = axis_ticklabels_overlap(x_labels)\n    y_overlap = axis_ticklabels_overlap(y_labels)\n    \n    return x_overlap, y_overlap", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert utils.axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    \"\"\"Return a boolean for whether the list of ticklabels have overlaps.\n\n    Parameters\n    ----------\n    labels : list of matplotlib ticklabels\n\n    Returns\n    -------\n    overlap : boolean\n        True if any of the labels overlap.\n\n    \"\"\"\n    if not labels:\n        return False\n    try:\n        bboxes = [l.get_window_extent() for l in labels]\n        overlaps = [b.count_overlaps(bboxes) for b in bboxes]\n        return max(overlaps) > 1\n    except RuntimeError:\n        return False\n\n\ndef axes_ticklabels_overlap(ax): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    # Get the extents of the ticklabels\n    extents = [label.get_window_extent() for label in labels]\n    \n    # Check for overlaps\n    for i in range(len(extents)):\n        for j in range(i + 1, len(extents)):\n            if extents[i].overlaps(extents[j]):\n                return True\n    return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    # Get the extents of each label\n    extents = [label.get_window_extent() for label in labels]\n    \n    # Check for overlaps\n    for i in range(len(extents)):\n        for j in range(i + 1, len(extents)):\n            if extents[i].overlaps(extents[j]):\n                return True\n    return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    # Get the extents of each label\n    extents = [label.get_window_extent() for label in labels]\n    \n    # Check for overlaps\n    for i in range(len(extents)):\n        for j in range(i + 1, len(extents)):\n            if extents[i].overlaps(extents[j]):\n                return True\n    return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    # Get the extents of the ticklabels\n    extents = [label.get_window_extent() for label in labels]\n    \n    # Check for overlaps\n    for i in range(len(extents)):\n        for j in range(i + 1, len(extents)):\n            if extents[i].overlaps(extents[j]):\n                return True\n    return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "axis_ticklabels_overlap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels):\n    # Get the extents of each label\n    extents = [label.get_window_extent() for label in labels]\n    \n    # Check for overlaps\n    for i in range(len(extents)):\n        for j in range(i + 1, len(extents)):\n            if extents[i].overlaps(extents[j]):\n                return True\n    return False", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_ticklabels_overlap():\n    rcmod.set()\n    f, ax = plt.subplots(figsize=(2, 2))\n    f.tight_layout()\n    assert not axis_ticklabels_overlap(ax.get_xticklabels())\n    big_strings = 'abcdefgh', 'ijklmnop'\n    ax.set_xlim(-0.5, 1.5)\n    ax.set_xticks([0, 1])\n    ax.set_xticklabels(big_strings)\n    assert axis_ticklabels_overlap(ax.get_xticklabels())\n    x, y = utils.axes_ticklabels_overlap(ax)\n    assert x\n    assert not y\n\ntest_ticklabels_overlap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef axis_ticklabels_overlap(labels): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\nfrom matplotlib.ticker import LogLocator, ScalarFormatter\n\ndef locator_to_legend_entries(locator, limits, dtype):\n    # Generate tick locations based on the locator\n    ticks = locator.tick_values(limits[0], limits[1])\n    \n    # Convert ticks to the specified dtype\n    raw_levels = [dtype(tick) for tick in ticks]\n    \n    # Format levels based on the type of locator\n    if isinstance(locator, LogLocator):\n        formatted_levels = [f\"{tick:.2e}\" for tick in raw_levels]\n    elif isinstance(locator, ScalarFormatter):\n        formatted_levels = [f\"{tick:.2f}\" for tick in raw_levels]\n    else:\n        formatted_levels = [str(tick) for tick in raw_levels]\n    \n    return raw_levels, formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\nfrom matplotlib.ticker import LogLocator, ScalarFormatter\n\ndef locator_to_legend_entries(locator, limits, dtype):\n    # Generate the raw levels using the locator\n    raw_levels = locator.tick_values(limits[0], limits[1])\n    \n    # Format the levels based on the type of locator\n    if isinstance(locator, LogLocator):\n        formatted_levels = [f\"{level:.2e}\" for level in raw_levels]\n    elif isinstance(locator, ScalarFormatter):\n        formatted_levels = [f\"{level:.2f}\" for level in raw_levels]\n    else:\n        formatted_levels = [str(level) for level in raw_levels]\n    \n    return raw_levels.astype(dtype).tolist(), formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype):\n    # Generate tick locations based on the locator\n    ticks = locator.tick_values(limits[0], limits[1])\n    \n    # Convert ticks to the specified dtype\n    raw_levels = ticks.astype(dtype).tolist()\n    \n    # Format levels based on the locator type\n    if isinstance(locator, mpl.ticker.LogLocator):\n        formatted_levels = [f'{level:.2e}' for level in raw_levels]\n    else:\n        formatted_levels = [str(level) for level in raw_levels]\n    \n    return raw_levels, formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\nfrom matplotlib.ticker import LogLocator, ScalarFormatter\n\ndef locator_to_legend_entries(locator, limits, dtype):\n    # Generate tick levels based on the locator\n    raw_levels = locator.tick_values(limits[0], limits[1])\n    \n    # Format the levels based on the type of locator\n    if isinstance(locator, LogLocator):\n        formatted_levels = [f'{level:.2e}' for level in raw_levels]\n    elif isinstance(locator, ScalarFormatter):\n        formatted_levels = [str(level) for level in raw_levels]\n    else:\n        formatted_levels = [str(level) for level in raw_levels]\n\n    return raw_levels.astype(dtype).tolist(), formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "locator_to_legend_entries", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype):\n    # Generate the tick locations using the locator\n    ticks = locator.tick_values(limits[0], limits[1])\n    \n    # Convert ticks to the specified dtype\n    raw_levels = [dtype(tick) for tick in ticks]\n    \n    # Format the levels based on the locator type\n    if isinstance(locator, mpl.ticker.LogLocator):\n        formatted_levels = [f\"{tick:.2e}\" for tick in raw_levels]\n    else:\n        formatted_levels = [str(tick) for tick in raw_levels]\n    \n    return raw_levels, formatted_levels", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_locator_to_legend_entries():\n    locator = mpl.ticker.MaxNLocator(nbins=3)\n    limits = 0.09, 0.4\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.15', '0.30']\n    limits = 0.8, 0.9\n    levels, str_levels = locator_to_legend_entries(locator, limits, float\n        )\n    assert str_levels == ['0.80', '0.84', '0.88']\n    limits = 1, 6\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['2', '4', '6']\n    locator = mpl.ticker.LogLocator(numticks=5)\n    limits = 5, 1425\n    levels, str_levels = locator_to_legend_entries(locator, limits, int)\n    assert str_levels == ['10', '100', '1000']\n    limits = 3e-05, 0.02\n    _, str_levels = locator_to_legend_entries(locator, limits, float)\n    for i, exp in enumerate([4, 3, 2]):\n        assert re.match(f'1e.0{exp}', str_levels[i])\n\ntest_locator_to_legend_entries()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef locator_to_legend_entries(locator, limits, dtype): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig):\n    # Check if the figure is stale\n    if fig.stale:\n        # Redraw the figure\n        fig.canvas.draw_idle()\n    \n    # Force the canvas to render the figure\n    fig.canvas.flush_events()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig):\n    # Check if the figure is stale and needs to be updated\n    if fig.stale:\n        fig.canvas.draw_idle()  # This will redraw the figure if it is stale\n    else:\n        fig.canvas.draw()  # Just draw the canvas if not stale\n\n    # Force the rendering of the figure\n    fig.canvas.flush_events()  # This ensures that the figure is updated on the screen", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig):\n    # Check if the figure is stale and needs to be redrawn\n    if fig.stale:\n        # Redraw the figure\n        fig.canvas.draw_idle()\n    \n    # Force the rendering of the figure\n    fig.canvas.flush_events()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig):\n    # Ensure the figure is updated and rendered\n    if fig.canvas is None:\n        raise ValueError(\"The figure does not have a canvas.\")\n    \n    # Check if the figure is stale and needs to be redrawn\n    if fig.stale:\n        fig.canvas.draw_idle()  # Update the figure\n        fig.stale = False  # Mark the figure as not stale anymore\n    \n    # Force the rendering of the figure\n    fig.canvas.flush_events()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_draw_figure", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig):\n    # Check if the figure is stale and needs to be redrawn\n    if fig.stale:\n        fig.canvas.draw_idle()  # Update the figure canvas\n    # Force the rendering of the figure\n    fig.canvas.flush_events()  # Ensure that the figure is displayed", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    utils.move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    _draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    utils.move_legend(ax, 'lower left', title=new_title)\n    _draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    utils.move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_draw_figure():\n    f, ax = plt.subplots()\n    ax.plot(['a', 'b', 'c'], [1, 2, 3])\n    _draw_figure(f)\n    assert not f.stale\n    assert ax.get_xticklabels()[0].get_text() == 'a'\n\ntest_draw_figure()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestBarPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, None, 3]\n        ax = barplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b', 'c']\n        assert ax.patches[0].get_height() == 1\n        assert ax.patches[1].get_height() == 3\nTestBarPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_grouper(self):\n        x, y = ['a', None, 'b'], [1, 2, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1]\n        assert [t.get_text() for t in ax.get_xticklabels()] == ['a', 'b']\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1])\n        assert_array_equal(ax.lines[0].get_ydata(), [1, 3])\nTestPointPlot().test_xy_with_na_grouper()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    def test_xy_with_na_value(self):\n        x, y = ['a', 'b', 'c'], [1, np.nan, 3]\n        ax = pointplot(x=x, y=y)\n        _draw_figure(ax.figure)\n        assert ax.get_xticks() == [0, 1, 2]\n        assert [t.get_text() for t in ax.get_xticklabels()] == x\n        assert_array_equal(ax.lines[0].get_xdata(), [0, 1, 2])\n        assert_array_equal(ax.lines[0].get_ydata(), y)\nTestPointPlot().test_xy_with_na_value()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _draw_figure(fig): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs):\n    # Get the current legend\n    current_legend = obj.get_legend()\n    \n    if current_legend is not None:\n        # Get handles and labels from the current legend\n        handles, labels = current_legend.get_legend_handles_labels()\n        \n        # Create a new legend at the specified location\n        obj.legend(handles, labels, loc=loc, **kwargs)\n        \n        # Remove the old legend\n        current_legend.remove()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs):\n    # Get the current legend\n    current_legend = obj.get_legend()\n    \n    if current_legend is not None:\n        # Get handles and labels from the current legend\n        handles, labels = current_legend.get_legend_handles_labels()\n        \n        # Create a new legend at the specified location\n        obj.legend(handles, labels, loc=loc, **kwargs)\n        \n        # Remove the old legend\n        current_legend.remove()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs):\n    # Get the current legend\n    current_legend = obj.get_legend()\n    \n    if current_legend is not None:\n        # Get the handles and labels from the current legend\n        handles, labels = current_legend.get_legend_handles_labels()\n        \n        # Create a new legend at the specified location\n        obj.legend(handles, labels, loc=loc, **kwargs)\n        \n        # Remove the old legend\n        current_legend.remove()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs):\n    # Get the current legend\n    current_legend = obj.get_legend()\n    \n    if current_legend is not None:\n        # Get the handles and labels from the current legend\n        handles, labels = current_legend.get_legend_handles_labels()\n        \n        # Remove the current legend\n        current_legend.remove()\n        \n        # Create a new legend at the specified location with the same handles and labels\n        obj.legend(handles, labels, loc=loc, **kwargs)", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "move_legend", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs):\n    # Get the current legend\n    current_legend = obj.get_legend()\n    \n    if current_legend is not None:\n        # Get handles and labels from the current legend\n        handles, labels = current_legend.get_legend_handles_labels()\n        \n        # Create a new legend at the specified location\n        obj.legend(handles, labels, loc=loc, **kwargs)\n        \n        # Remove the old legend\n        current_legend.remove()", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_move_legend_matplotlib_objects():\n    fig, ax = plt.subplots()\n    colors = 'C2', 'C5'\n    labels = 'first label', 'second label'\n    title = 'the legend'\n    for color, label in zip(colors, labels):\n        ax.plot([0, 1], color=color, label=label)\n    ax.legend(loc='upper right', title=title)\n    utils._draw_figure(fig)\n    xfm = ax.transAxes.inverted().transform\n    old_pos = xfm(ax.legend_.legendPatch.get_extents())\n    new_fontsize = 14\n    move_legend(ax, 'lower left', title_fontsize=new_fontsize)\n    utils._draw_figure(fig)\n    new_pos = xfm(ax.legend_.legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert ax.legend_.get_title().get_text() == title\n    assert ax.legend_.get_title().get_size() == new_fontsize\n    new_title = 'new title'\n    move_legend(ax, 'lower left', title=new_title)\n    utils._draw_figure(fig)\n    assert ax.legend_.get_title().get_text() == new_title\n    fig.legend(loc='upper right', title=title)\n    _draw_figure(fig)\n    xfm = fig.transFigure.inverted().transform\n    old_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    move_legend(fig, 'lower left', title=new_title)\n    _draw_figure(fig)\n    new_pos = xfm(fig.legends[0].legendPatch.get_extents())\n    assert (new_pos < old_pos).all()\n    assert fig.legends[0].get_title().get_text() == new_title\n\ntest_move_legend_matplotlib_objects()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef move_legend(obj, loc, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): \n    if _version_predates(mpl.__version__, '3.7'):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): \n    if _version_predates(mpl.__version__, \"3.7\"):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): \n    if _version_predates(mpl.__version__, \"3.7\"):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): \n    if _version_predates(mpl.__version__, \"3.7\"):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_legend_handles", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): \n    if _version_predates(mpl.__version__, \"3.7\"):\n        return legend.legendHandles\n    else:\n        return legend.legend_handles", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_contents(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        ax = pointplot(x=x, y=y, hue=hue)\n        _draw_figure(ax.figure)\n        legend = ax.get_legend()\n        assert [t.get_text() for t in legend.texts] == ['x', 'y']\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == 'o'\n            assert handle.get_linestyle() == '-'\n            assert same_color(handle.get_color(), f'C{i}')\nTestPointPlot().test_legend_contents()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_set_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(marker='s', linewidth=1)\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['marker']\n            assert handle.get_linewidth() == kws['linewidth']\nTestPointPlot().test_legend_set_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nclass SharedAxesLevelTests:\n\n    def orient_indices(self, orient):\n        pos_idx = ['x', 'y'].index(orient)\n        val_idx = ['y', 'x'].index(orient)\n        return pos_idx, val_idx\n\n    @pytest.fixture\n    def common_kws(self):\n        return {}\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_labels_long(self, long_df, orient):\n        depend = {'x': 'y', 'y': 'x'}[orient]\n        kws = {orient: 'a', depend: 'y', 'hue': 'b'}\n        ax = self.func(long_df, **kws)\n        _draw_figure(ax.figure)\n        assert getattr(ax, f'get_{orient}label')() == kws[orient]\n        assert getattr(ax, f'get_{depend}label')() == kws[depend]\n        get_ori_labels = getattr(ax, f'get_{orient}ticklabels')\n        ori_labels = [t.get_text() for t in get_ori_labels()]\n        ori_levels = categorical_order(long_df[kws[orient]])\n        assert ori_labels == ori_levels\n        legend = ax.get_legend()\n        assert legend.get_title().get_text() == kws['hue']\n        hue_labels = [t.get_text() for t in legend.texts]\n        hue_levels = categorical_order(long_df[kws['hue']])\n        assert hue_labels == hue_levels\n\n    def test_labels_wide(self, wide_df):\n        wide_df = wide_df.rename_axis('cols', axis=1)\n        ax = self.func(wide_df)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == wide_df.columns.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, wide_df.columns):\n            assert label == level\n\n    def test_labels_hue_order(self, long_df):\n        hue_var = 'b'\n        hue_order = categorical_order(long_df[hue_var])[::-1]\n        ax = self.func(long_df, x='a', y='y', hue=hue_var, hue_order=hue_order)\n        legend = ax.get_legend()\n        hue_labels = [t.get_text() for t in legend.texts]\n        assert hue_labels == hue_order\n\n    def test_color(self, long_df, common_kws):\n        common_kws.update(data=long_df, x='a', y='y')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(ax=ax, **common_kws)\n        self.func(ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(color='C2', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(color='C3', ax=ax, **common_kws)\n        assert self.get_last_color(ax) == to_rgba('C3')\n\n    def test_two_calls(self):\n        ax = plt.figure().subplots()\n        self.func(x=['a', 'b', 'c'], y=[1, 2, 3], ax=ax)\n        self.func(x=['e', 'f'], y=[4, 5], ax=ax)\n        assert ax.get_xlim() == (-0.5, 4.5)\n\n    def test_redundant_hue_legend(self, long_df):\n        ax = self.func(long_df, x='a', y='y', hue='a')\n        assert ax.get_legend() is None\n        ax.clear()\n        self.func(long_df, x='a', y='y', hue='a', legend=True)\n        assert ax.get_legend() is not None\n\n    @pytest.mark.parametrize('orient', ['x', 'y'])\n    def test_log_scale(self, long_df, orient):\n        depvar = {'x': 'y', 'y': 'x'}[orient]\n        variables = {orient: 'a', depvar: 'z'}\n        ax = self.func(long_df, **variables, log_scale=True)\n        assert getattr(ax, f'get_{orient}scale')() == 'linear'\n        assert getattr(ax, f'get_{depvar}scale')() == 'log'\nclass SharedAggTests(SharedAxesLevelTests):\n    def test_labels_flat(self):\n        ind = pd.Index(['a', 'b', 'c'], name='x')\n        ser = pd.Series([1, 2, 3], ind, name='y')\n        ax = self.func(ser)\n        _draw_figure(ax.figure)\n        assert ax.get_xlabel() == ind.name\n        assert ax.get_ylabel() == ser.name\n        labels = [t.get_text() for t in ax.get_xticklabels()]\n        for label, level in zip(labels, ind):\n            assert label == level\nclass TestPointPlot(SharedAggTests):\n    @pytest.mark.skipif(_version_predates(mpl, '3.6'), reason=\n        'Legend handle missing marker property')\n    def test_legend_synced_props(self):\n        x, y = ['a', 'a', 'b', 'b'], [1, 2, 3, 4]\n        hue = ['x', 'y', 'x', 'y']\n        kws = dict(markers=['s', 'd'], linestyles=['--', ':'])\n        ax = pointplot(x=x, y=y, hue=hue, **kws)\n        legend = ax.get_legend()\n        for i, handle in enumerate(get_legend_handles(legend)):\n            assert handle.get_marker() == kws['markers'][i]\n            assert handle.get_linestyle() == kws['linestyles'][i]\nTestPointPlot().test_legend_synced_props()", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_legend_handles(legend): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color):\n    # Convert color to RGB if it's a hex code or HTML color name\n    rgb = to_rgb(color)\n    \n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = rgb\n    \n    # Apply the formula for relative luminance\n    # The formula is: L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n    luminance = 0.2126 * (r ** 2.2) + 0.7152 * (g ** 2.2) + 0.0722 * (b ** 2.2)\n    \n    return luminance", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color):\n    # Convert the input color to RGB format\n    rgb = to_rgb(color)\n    \n    # Calculate the relative luminance using the formula\n    r, g, b = rgb\n    # Apply the formula for relative luminance\n    luminance = 0.2126 * (r ** 2.2) + 0.7152 * (g ** 2.2) + 0.0722 * (b ** 2.2)\n    \n    return luminance", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color):\n    # Convert the color to RGB format\n    rgb = to_rgb(color)\n    \n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = rgb\n    \n    # Apply the formula for relative luminance\n    # Using the formula: L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n    luminance = 0.2126 * (r ** 2.2) + 0.7152 * (g ** 2.2) + 0.0722 * (b ** 2.2)\n    \n    return luminance", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color):\n    # Convert the color to RGB format\n    rgb = to_rgb(color)\n    \n    # Normalize the RGB values to the range [0, 1]\n    r, g, b = rgb\n    \n    # Apply the formula for relative luminance\n    # Using the formula: L = 0.2126 * R + 0.7152 * G + 0.0722 * B\n    luminance = 0.2126 * (r ** 2.2) + 0.7152 * (g ** 2.2) + 0.0722 * (b ** 2.2)\n    \n    return luminance", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "relative_luminance", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color):\n    # Convert color to RGB if it's a hex code or HTML color name\n    rgb = to_rgb(color)\n    \n    # Convert RGB values to linear space\n    r, g, b = rgb\n    r = r / 255.0\n    g = g / 255.0\n    b = b / 255.0\n    \n    # Apply the formula for relative luminance\n    r = r / 12.92 if r <= 0.03928 else ((r + 0.055) / 1.055) ** 2.4\n    g = g / 12.92 if g <= 0.03928 else ((g + 0.055) / 1.055) ** 2.4\n    b = b / 12.92 if b <= 0.03928 else ((b + 0.055) / 1.055) ** 2.4\n    \n    # Calculate the relative luminance\n    luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b\n    \n    return luminance", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_relative_luminance():\n    \"\"\"Test relative luminance.\"\"\"\n    out1 = relative_luminance('white')\n    assert out1 == 1\n    out2 = relative_luminance('#000000')\n    assert out2 == 0\n    out3 = relative_luminance((0.25, 0.5, 0.75))\n    assert out3 == pytest.approx(0.201624536)\n    rgbs = mpl.cm.RdBu(np.linspace(0, 1, 10))\n    lums1 = [relative_luminance(rgb) for rgb in rgbs]\n    lums2 = relative_luminance(rgbs)\n    for lum1, lum2 in zip(lums1, lums2):\n        assert lum1 == pytest.approx(lum2)\n\ntest_relative_luminance()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef relative_luminance(color): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle():\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    if not colors:\n        return ['.15']\n    return colors", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle():\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    if not colors:\n        return ['.15']\n    return colors", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle():\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    if not colors:\n        return ['.15']  # dark gray color\n    return colors", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle():\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    if not colors:\n        return ['.15']\n    return colors", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_color_cycle", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle():\n    colors = plt.rcParams['axes.prop_cycle'].by_key()['color']\n    if not colors:\n        return ['.15']\n    return colors", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestAxesStyle(RCParamFixtures):\n    def test_set_with_palette(self):\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette='deep', color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        pal = palettes.color_palette('deep')\n        rcmod.set_theme(palette=pal)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme(palette=pal, color_codes=False)\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.reset_orig()\n        rcmod.set_theme()\n    \nTestAxesStyle().test_set_with_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        rcmod.set_palette('deep')\n        assert get_color_cycle() == palettes.color_palette('deep', 10)\n        rcmod.set_palette('pastel6')\n        assert get_color_cycle() == palettes.color_palette('pastel6', 6)\n        rcmod.set_palette('dark', 4)\n        assert get_color_cycle() == palettes.color_palette('dark', 4)\n        rcmod.set_palette('Set2', color_codes=True)\n        assert get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        rcmod.set_palette(pal)\n        assert pal == get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_context(self):\n        default_pal = palettes.color_palette()\n        context_pal = palettes.color_palette('muted')\n        with palettes.color_palette(context_pal):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == default_pal\n    \nTestColorPalettes().test_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        rcmod.set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert get_color_cycle() == context_pal\n        assert get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef get_color_cycle(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func):\n    # Get the signature of the call_func\n    call_signature = inspect.signature(call_func)\n    # Get the signature of the source_func\n    source_signature = inspect.signature(source_func)\n\n    # Iterate over the parameters of the call_func\n    for param_name, param in call_signature.parameters.items():\n        # Check if the parameter is a keyword argument and not already in kws\n        if param_name not in kws and param.default is param.empty:\n            # If the parameter is required and not in kws, we skip it\n            continue\n        # If the parameter is not in kws, we check the source_func for a default\n        if param_name not in kws:\n            # Check if the parameter exists in the source_func\n            if param_name in source_signature.parameters:\n                # Get the default value from the source_func\n                source_param = source_signature.parameters[param_name]\n                if source_param.default is not source_param.empty:\n                    kws[param_name] = source_param.default\n\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func):\n    # Get the signature of the call_func\n    call_signature = inspect.signature(call_func)\n    \n    # Get the signature of the source_func\n    source_signature = inspect.signature(source_func)\n    \n    # Iterate over the parameters of the call_func\n    for param_name, param in call_signature.parameters.items():\n        # Check if the parameter is a keyword argument\n        if param.default is param.empty and param_name not in kws:\n            # If it's required and not in kws, check source_func for default\n            if param_name in source_signature.parameters:\n                source_param = source_signature.parameters[param_name]\n                if source_param.default is not source_param.empty:\n                    # Assign the default value from source_func to kws\n                    kws[param_name] = source_param.default\n\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func):\n    # Get the signature of the call_func\n    call_signature = inspect.signature(call_func)\n    # Get the signature of the source_func\n    source_signature = inspect.signature(source_func)\n\n    # Iterate over the parameters of the call_func\n    for param_name, param in call_signature.parameters.items():\n        # Check if the parameter is required and not already in kws\n        if param.default == inspect.Parameter.empty and param_name not in kws:\n            # Check if the parameter exists in the source_func\n            if param_name in source_signature.parameters:\n                # Get the default value from the source_func\n                default_value = source_signature.parameters[param_name].default\n                if default_value != inspect.Parameter.empty:\n                    kws[param_name] = default_value\n\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func):\n    # Get the signature of the call_func\n    call_signature = inspect.signature(call_func)\n    # Get the signature of the source_func\n    source_signature = inspect.signature(source_func)\n\n    # Iterate over the parameters of the call_func\n    for param_name, param in call_signature.parameters.items():\n        # Check if the parameter is required and not already in kws\n        if param_name not in kws and param.default is param.empty:\n            # If it's required, we skip it since we can't provide a default\n            continue\n        # If the parameter is not in kws, we check the source_func for a default\n        if param_name not in kws:\n            # Get the default value from the source_func if available\n            if param_name in source_signature.parameters:\n                source_param = source_signature.parameters[param_name]\n                if source_param.default is not source_param.empty:\n                    kws[param_name] = source_param.default\n\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_assign_default_kwargs", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func):\n    # Get the signature of the call_func\n    call_signature = inspect.signature(call_func)\n    # Get the signature of the source_func\n    source_signature = inspect.signature(source_func)\n\n    # Iterate over the parameters of the call_func\n    for param_name, param in call_signature.parameters.items():\n        # Check if the parameter is a keyword argument\n        if param.default is param.empty and param_name not in kws:\n            # If the parameter is required and not in kws, check source_func\n            if param_name in source_signature.parameters:\n                source_param = source_signature.parameters[param_name]\n                # Assign the default value from source_func if it exists\n                if source_param.default is not source_param.empty:\n                    kws[param_name] = source_param.default\n\n    return kws", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_assign_default_kwargs():\n\n    def f(a, b, c, d):\n        pass\n\n    def g(c=1, d=2):\n        pass\n    kws = {'c': 3}\n    kws = _assign_default_kwargs(kws, f, g)\n    assert kws == {'c': 3, 'd': 2}\n\ntest_assign_default_kwargs()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _assign_default_kwargs(kws, call_func, source_func): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False):\n    if prefix:\n        if not any(value.startswith(option) for option in options):\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. \"\n                             f\"Allowed values are prefixes of: {options}\")\n    else:\n        if value not in options:\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. \"\n                             f\"Allowed values are: {options}\")\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False):\n    if prefix:\n        if not any(value.startswith(option) for option in options):\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. \"\n                             f\"Allowed options are prefixes of: {options}\")\n    else:\n        if value not in options:\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. \"\n                             f\"Allowed values are: {options}\")\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False):\n    if prefix:\n        if not any(value.startswith(option) for option in options):\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed values are prefixes of {options}.\")\n    else:\n        if value not in options:\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed values are {options}.\")\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False):\n    if prefix:\n        if not any(value.startswith(option) for option in options):\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed prefixes are: {options}\")\n    else:\n        if value not in options:\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed values are: {options}\")\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_check_argument", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False):\n    if prefix:\n        if not any(value.startswith(option) for option in options):\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed values are prefixes of: {options}\")\n    else:\n        if value not in options:\n            raise ValueError(f\"Invalid value for '{param}': '{value}'. Allowed values are: {options}\")\n    return value", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_check_argument():\n    opts = ['a', 'b', None]\n    assert _check_argument('arg', opts, 'a') == 'a'\n    assert _check_argument('arg', opts, None) is None\n    assert _check_argument('arg', opts, 'aa', prefix=True) == 'aa'\n    assert _check_argument('arg', opts, None, prefix=True) is None\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c')\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts, 'c', prefix=True)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None)\n    with pytest.raises(ValueError, match='The value for `arg`'):\n        _check_argument('arg', opts[:-1], None, prefix=True)\n\ntest_check_argument()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _check_argument(param, options, value, prefix=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci):\n    if ci is not None:\n        warnings.warn(\n            \"'ci' parameter is deprecated, use 'errorbar' instead.\",\n            FutureWarning,\n        )\n        if ci == 'sd':\n            errorbar = 'sd'\n        elif ci == 'deprecated':\n            errorbar = ('ci', 'deprecated')\n        else:\n            errorbar = ('ci', ci)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci):\n    if ci is not None:\n        warnings.warn(\n            \"The 'ci' parameter is deprecated and will be removed in a future version. \"\n            \"Please use the 'errorbar' parameter instead.\",\n            FutureWarning\n        )\n        if ci == 'sd':\n            errorbar = 'sd'\n        elif ci is None:\n            errorbar = None\n        else:\n            errorbar = ('ci', ci)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci):\n    if ci is not None:\n        warnings.warn(\n            \"The 'ci' parameter is deprecated. Please use 'errorbar' instead.\",\n            FutureWarning\n        )\n        if ci == 'sd':\n            errorbar = 'sd'\n        elif ci == 'deprecated':\n            errorbar = ('ci', 'deprecated')\n        else:\n            errorbar = ('ci', ci)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci):\n    if ci is not None:\n        warnings.warn(\n            \"'ci' parameter is deprecated, use 'errorbar' instead.\",\n            FutureWarning,\n        )\n        if ci == 'sd':\n            errorbar = 'sd'\n        elif ci == 'deprecated':\n            errorbar = ('ci', 'deprecated')\n        else:\n            errorbar = ('ci', ci)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_deprecate_ci", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci):\n    if ci is not None:\n        warnings.warn(\n            \"The 'ci' parameter is deprecated and will be removed in a future version. \"\n            \"Please use the 'errorbar' parameter instead.\",\n            FutureWarning\n        )\n        if ci == 'sd':\n            errorbar = 'sd'\n        elif ci is None:\n            errorbar = None\n        else:\n            errorbar = ('ci', ci)\n    return errorbar", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\ndef test_deprecate_ci():\n    msg = '\\n\\nThe `ci` parameter is deprecated. Use `errorbar='\n    with pytest.warns(FutureWarning, match=msg + 'None'):\n        out = _deprecate_ci(None, None)\n    assert out is None\n    with pytest.warns(FutureWarning, match=msg + \"'sd'\"):\n        out = _deprecate_ci(None, 'sd')\n    assert out == 'sd'\n    with pytest.warns(FutureWarning, match=msg + \"\\\\('ci', 68\\\\)\"):\n        out = _deprecate_ci(None, 68)\n    assert out == ('ci', 68)\n\ntest_deprecate_ci()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef _deprecate_ci(errorbar, ci): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "despine", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False):\n    if fig is None:\n        fig = plt.gcf()\n    if ax is None:\n        ax = fig.get_axes()\n\n    if not isinstance(ax, (list, tuple)):\n        ax = [ax]\n\n    for a in ax:\n        if top:\n            a.spines['top'].set_visible(False)\n        if right:\n            a.spines['right'].set_visible(False)\n        if left:\n            a.spines['left'].set_visible(False)\n        if bottom:\n            a.spines['bottom'].set_visible(False)\n\n        if offset is not None:\n            if isinstance(offset, dict):\n                for spine, value in offset.items():\n                    if spine in a.spines:\n                        a.spines[spine].set_position(('outward', value))\n            else:\n                for spine in a.spines:\n                    a.spines[spine].set_position(('outward', offset))\n\n        if trim:\n            for spine in ['left', 'bottom']:\n                if a.spines[spine].get_visible():\n                    ticks = a.get_xticks() if spine == 'bottom' else a.get_yticks()\n                    if len(ticks) > 0:\n                        a.spines[spine].set_bounds(ticks[0], ticks[-1])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "despine", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False):\n    if fig is None:\n        fig = plt.gcf()\n    if ax is None:\n        axes = fig.get_axes()\n    else:\n        axes = [ax]\n\n    for ax in axes:\n        if top:\n            ax.spines['top'].set_visible(False)\n        if right:\n            ax.spines['right'].set_visible(False)\n        if left:\n            ax.spines['left'].set_visible(False)\n        if bottom:\n            ax.spines['bottom'].set_visible(False)\n\n        if offset is not None:\n            if isinstance(offset, dict):\n                for spine, value in offset.items():\n                    ax.spines[spine].set_position(('outward', value))\n            else:\n                for spine in ax.spines:\n                    ax.spines[spine].set_position(('outward', offset))\n\n        if trim:\n            for spine in ['left', 'bottom']:\n                if ax.spines[spine].get_visible():\n                    ticks = ax.get_xticks() if spine == 'bottom' else ax.get_yticks()\n                    if len(ticks) > 0:\n                        ax.spines[spine].set_bounds(ticks[0], ticks[-1])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "despine", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False):\n    if fig is None:\n        fig = plt.gcf()\n    if ax is None:\n        ax = fig.get_axes()\n\n    if not isinstance(ax, (list, tuple)):\n        ax = [ax]\n\n    for a in ax:\n        if top:\n            a.spines['top'].set_visible(False)\n        if right:\n            a.spines['right'].set_visible(False)\n        if left:\n            a.spines['left'].set_visible(False)\n        if bottom:\n            a.spines['bottom'].set_visible(False)\n\n        if offset is not None:\n            if isinstance(offset, dict):\n                for spine, value in offset.items():\n                    if spine in a.spines:\n                        a.spines[spine].set_position(('outward', value))\n            else:\n                for spine in a.spines:\n                    a.spines[spine].set_position(('outward', offset))\n\n        if trim:\n            for spine in ['left', 'bottom']:\n                if a.spines[spine].get_visible():\n                    ticks = a.get_xticks() if spine == 'bottom' else a.get_yticks()\n                    if len(ticks) > 0:\n                        a.spines[spine].set_bounds(ticks[0], ticks[-1])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "despine", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False):\n    if fig is None:\n        fig = plt.gcf()\n    if ax is None:\n        ax = fig.get_axes()\n\n    if not isinstance(ax, (list, tuple)):\n        ax = [ax]\n\n    for a in ax:\n        if top:\n            a.spines['top'].set_visible(False)\n        if right:\n            a.spines['right'].set_visible(False)\n        if left:\n            a.spines['left'].set_visible(False)\n        if bottom:\n            a.spines['bottom'].set_visible(False)\n\n        if offset is not None:\n            if isinstance(offset, dict):\n                for spine, value in offset.items():\n                    if spine in a.spines:\n                        a.spines[spine].set_position(('outward', value))\n            else:\n                for spine in a.spines:\n                    a.spines[spine].set_position(('outward', offset))\n\n        if trim:\n            for spine in ['left', 'bottom']:\n                if a.spines[spine].get_visible():\n                    ticks = a.get_xticks() if spine == 'bottom' else a.get_yticks()\n                    if len(ticks) > 0:\n                        a.spines[spine].set_bounds(ticks[0], ticks[-1])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "despine", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/utils.py", "response": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=False, offset=None, trim=False):\n    if fig is None:\n        fig = plt.gcf()\n    if ax is None:\n        ax = fig.get_axes()\n\n    if not isinstance(ax, (list, tuple)):\n        ax = [ax]\n\n    for a in ax:\n        if top:\n            a.spines['top'].set_visible(False)\n        if right:\n            a.spines['right'].set_visible(False)\n        if left:\n            a.spines['left'].set_visible(False)\n        if bottom:\n            a.spines['bottom'].set_visible(False)\n\n        if offset is not None:\n            if isinstance(offset, dict):\n                for spine, value in offset.items():\n                    if spine in a.spines:\n                        a.spines[spine].set_position(('outward', value))\n            else:\n                for spine in a.spines:\n                    a.spines[spine].set_position(('outward', offset))\n\n        if trim:\n            for spine in ['left', 'bottom']:\n                if a.spines[spine].get_visible():\n                    ticks = a.get_xticks() if spine == 'bottom' else a.get_yticks()\n                    a.spines[spine].set_bounds(ticks[0], ticks[-1])", "test_code_list": [{"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_noticks(self):\n        f, ax = plt.subplots()\n        ax.plot([1, 2, 3], [1, 2, 3])\n        ax.set_yticks([])\n        despine(trim=True)\n        assert ax.get_yticks().size == 0\n    \nTestSpineUtils().test_despine_trim_noticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_trim_categorical(self):\n        f, ax = plt.subplots()\n        ax.plot(['a', 'b', 'c'], [1, 2, 3])\n        despine(trim=True)\n        bounds = ax.spines['left'].get_bounds()\n        assert bounds == (1, 3)\n        bounds = ax.spines['bottom'].get_bounds()\n        assert bounds == (0, 2)\n    \nTestSpineUtils().test_despine_trim_categorical()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}, {"test_code": "import re\nimport tempfile\nfrom types import ModuleType\nfrom urllib.request import urlopen\nfrom http.client import HTTPException\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom cycler import cycler\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom pandas.testing import assert_series_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn import scatterplot\nfrom seaborn.utils import get_dataset_names\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\nfrom seaborn.utils import load_dataset\nfrom seaborn.utils import _assign_default_kwargs\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _deprecate_ci\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import DATASET_NAMES_URL\nfrom seaborn._compat import get_legend_handles\nfrom seaborn.axisgrid import FacetGrid\n\nclass TestSpineUtils():\n    def test_despine_moved_ticks(self):\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.yaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, left=True, right=False)\n        for t in ax.yaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(True)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert t.tick2line.get_visible()\n        plt.close(f)\n        f, ax = plt.subplots()\n        for t in ax.xaxis.majorTicks:\n            t.tick1line.set_visible(False)\n        despine(ax=ax, bottom=True, top=False)\n        for t in ax.xaxis.majorTicks:\n            assert not t.tick2line.get_visible()\n        plt.close(f)\n    \nTestSpineUtils().test_despine_moved_ticks()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_utils.py"}], "method_code_mask": "import os\nimport inspect\nimport warnings\nimport colorsys\nfrom contextlib import contextmanager\nfrom urllib.request import urlopen\nfrom urllib.request import urlretrieve\nfrom types import ModuleType\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.colors import to_rgb\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\nfrom seaborn._core.typing import deprecated\nfrom seaborn.external.version import Version\nfrom seaborn.external.appdirs import user_cache_dir\nfrom seaborn.axisgrid import Grid\nfrom seaborn._compat import get_legend_handles\n\n\ndef despine(fig=None, ax=None, top=True, right=True, left=False, bottom=\n    False, offset=None, trim=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    \n    # Prepare the data\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle the hue variable\n    if hue is not None:\n        hue_data = data[hue]\n        if hue_order is not None:\n            hue_data = pd.Categorical(hue_data, categories=hue_order)\n        if palette is not None:\n            colors = mpl.colors.to_rgba_array(palette)\n            color_map = {level: colors[i] for i, level in enumerate(hue_data.cat.categories)}\n            point_colors = hue_data.map(color_map)\n        else:\n            point_colors = hue_data\n    \n    # Handle the size variable\n    if size is not None:\n        size_data = data[size]\n        if size_norm is not None:\n            size_data = size_norm(size_data)\n        if sizes is not None:\n            sizes = np.interp(size_data, (size_data.min(), size_data.max()), sizes)\n        else:\n            sizes = size_data\n    \n    # Handle the style variable\n    if style is not None:\n        style_data = data[style]\n        if style_order is not None:\n            style_data = pd.Categorical(style_data, categories=style_order)\n        if markers is True:\n            markers = ['o'] * len(style_data.cat.categories)  # Default marker\n        marker_map = {level: markers[i] for i, level in enumerate(style_data.cat.categories)}\n        point_markers = style_data.map(marker_map)\n    else:\n        point_markers = ['o'] * len(data)  # Default marker if no style\n    \n    # Create scatter plot\n    for i in range(len(data)):\n        ax.scatter(data[x].iloc[i], data[y].iloc[i], \n                   color=point_colors.iloc[i], \n                   s=sizes.iloc[i], \n                   marker=point_markers.iloc[i], \n                   **kwargs)\n    \n    # Handle legend\n    if legend != 'auto':\n        ax.legend()\n    \n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    \n    # Prepare the data\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle the DataFrame input\n    if isinstance(data, pd.DataFrame):\n        x_data = data[x]\n        y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n        if size is not None:\n            size_data = data[size]\n        if style is not None:\n            style_data = data[style]\n    else:\n        x_data = np.array(x)\n        y_data = np.array(y)\n        hue_data = np.array(hue) if hue is not None else None\n        size_data = np.array(size) if size is not None else None\n        style_data = np.array(style) if style is not None else None\n\n    # Handle hue\n    if hue is not None:\n        unique_hues = np.unique(hue_data)\n        if palette is None:\n            palette = mpl.cm.viridis(np.linspace(0, 1, len(unique_hues)))\n        hue_colors = {hue_val: palette[i] for i, hue_val in enumerate(unique_hues)}\n        colors = [hue_colors[h] for h in hue_data]\n    else:\n        colors = 'b'  # Default color if no hue\n\n    # Handle size\n    if size is not None:\n        if size_norm is not None:\n            sizes = size_norm(size_data)\n        else:\n            sizes = np.interp(size_data, (size_data.min(), size_data.max()), (10, 100))\n    else:\n        sizes = 50  # Default size if no size variable\n\n    # Handle style\n    if style is not None:\n        unique_styles = np.unique(style_data)\n        if markers is True:\n            markers = ['o', 's', '^', 'D', 'P', '*', 'X'][:len(unique_styles)]\n        style_markers = {style_val: markers[i] for i, style_val in enumerate(unique_styles)}\n        marker_styles = [style_markers[s] for s in style_data]\n    else:\n        marker_styles = 'o'  # Default marker if no style variable\n\n    # Create scatter plot\n    scatter = ax.scatter(x_data, y_data, c=colors, s=sizes, marker=marker_styles, **kwargs)\n\n    # Handle legend\n    if legend != False:\n        if legend == 'auto':\n            ax.legend(*scatter.legend_elements(), title=hue)\n\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    \n    # Prepare the data\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle the DataFrame input\n    if isinstance(data, pd.DataFrame):\n        x_data = data[x]\n        y_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n        if size is not None:\n            size_data = data[size]\n        if style is not None:\n            style_data = data[style]\n    else:\n        x_data = data[:, 0]\n        y_data = data[:, 1]\n        hue_data = hue\n        size_data = size\n        style_data = style\n\n    # Handle hue\n    if hue is not None:\n        unique_hues = np.unique(hue_data)\n        if palette is None:\n            palette = plt.get_cmap('viridis', len(unique_hues))\n        colors = palette(np.arange(len(unique_hues)))\n\n    # Handle size\n    if size is not None:\n        if sizes is None:\n            sizes = [20] * len(size_data)\n        sizes = np.interp(size_data, (size_data.min(), size_data.max()), (sizes[0], sizes[1]))\n\n    # Handle style\n    if style is not None:\n        unique_styles = np.unique(style_data)\n        if markers is True:\n            markers = ['o'] * len(unique_styles)  # Default marker\n        markers = markers[:len(unique_styles)]\n\n    # Create scatter plot\n    scatter = ax.scatter(x_data, y_data, c=colors, s=sizes, marker=markers, **kwargs)\n\n    # Handle legend\n    if legend != 'auto':\n        ax.legend(*scatter.legend_elements(), title=hue)\n\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    \n    # Prepare the data\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle the data input\n    if isinstance(data, pd.DataFrame):\n        x_data = data[x]\n        y_data = data[y]\n        hue_data = data[hue] if hue is not None else None\n        size_data = data[size] if size is not None else None\n        style_data = data[style] if style is not None else None\n    else:\n        x_data = data[:, 0]\n        y_data = data[:, 1]\n        hue_data = data[:, 2] if hue is not None else None\n        size_data = data[:, 3] if size is not None else None\n        style_data = data[:, 4] if style is not None else None\n\n    # Handle hue\n    if hue is not None:\n        unique_hues = np.unique(hue_data)\n        hue_palette = mpl.cm.get_cmap(palette, len(unique_hues)) if palette else mpl.cm.viridis\n        hue_colors = hue_palette(np.arange(len(unique_hues)))\n\n    # Handle size\n    if size is not None:\n        if size_norm is not None:\n            size_data = size_norm(size_data)\n        sizes = np.interp(size_data, (size_data.min(), size_data.max()), (10, 200)) if sizes is None else sizes\n\n    # Handle style\n    if style is not None:\n        unique_styles = np.unique(style_data)\n        if markers is True:\n            markers = ['o'] * len(unique_styles)  # Default marker\n        style_markers = {unique_styles[i]: markers[i] for i in range(len(unique_styles))}\n\n    # Create scatter plot\n    scatter = ax.scatter(x_data, y_data, c=hue_colors, s=sizes, marker='o', **kwargs)\n\n    # Add legend if required\n    if legend != 'none':\n        handles = []\n        if hue is not None:\n            for i, hue_value in enumerate(unique_hues):\n                handles.append(mpl.lines.Line2D([0], [0], marker='o', color='w', label=hue_value,\n                                                  markerfacecolor=hue_colors[i]))\n        if style is not None:\n            for style_value in unique_styles:\n                handles.append(mpl.lines.Line2D([0], [0], marker=style_markers[style_value], color='w',\n                                                  label=style_value, markersize=10))\n        ax.legend(handles=handles, title=hue if hue is not None else style)\n\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "scatterplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs):\n    \n    # Prepare the data\n    if ax is None:\n        ax = plt.gca()\n    \n    # Handle the hue variable\n    if hue is not None:\n        hue_data = data[hue]\n        if hue_order is not None:\n            hue_data = pd.Categorical(hue_data, categories=hue_order)\n        if hue_norm is not None:\n            hue_data = hue_norm(hue_data)\n        colors = mpl.cm.get_cmap(palette)(hue_data)\n    else:\n        colors = 'b'  # Default color if no hue is provided\n\n    # Handle the size variable\n    if size is not None:\n        size_data = data[size]\n        if size_order is not None:\n            size_data = pd.Categorical(size_data, categories=size_order)\n        if size_norm is not None:\n            size_data = size_norm(size_data)\n        sizes = np.interp(size_data, (size_data.min(), size_data.max()), (10, 200))  # Scale sizes\n    else:\n        sizes = 50  # Default size if no size is provided\n\n    # Handle the style variable\n    if style is not None:\n        style_data = data[style]\n        if style_order is not None:\n            style_data = pd.Categorical(style_data, categories=style_order)\n        markers = [markers[i] for i in style_data.codes] if isinstance(markers, list) else markers\n    else:\n        markers = 'o'  # Default marker if no style is provided\n\n    # Create the scatter plot\n    for i, (x_val, y_val, color, size_val, marker) in enumerate(zip(data[x], data[y], colors, sizes, markers)):\n        ax.scatter(x_val, y_val, color=color, s=size_val, marker=marker, **kwargs)\n\n    # Handle legend\n    if legend != 'auto':\n        ax.legend(loc=legend)\n\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n        assert ax.get_legend().get_title().get_text() == ''\n    \nTestScatterPlotter().test_legend_numeric_hue_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_hue_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, hue=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_hue_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_full(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='full')\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == [str(z_i) for z_i in sorted(set(z))]\n    \nTestScatterPlotter().test_legend_numeric_size_full()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_legend_numeric_size_brief(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = scatterplot(x=x, y=y, size=z, legend='brief')\n        _, labels = ax.get_legend_handles_labels()\n        assert len(labels) < len(set(z))\n    \nTestScatterPlotter().test_legend_numeric_size_brief()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_literal_attribute_vectors(self):\n        f, ax = plt.subplots()\n        x = y = [1, 2, 3]\n        s = [5, 10, 15]\n        c = [(1, 1, 0, 1), (1, 0, 1, 0.5), (0.5, 1, 0, 1)]\n        scatterplot(x=x, y=y, c=c, s=s, ax=ax)\n        points, = ax.collections\n        assert_array_equal(points.get_sizes().squeeze(), s)\n        assert_array_equal(points.get_facecolors(), c)\n    \nTestScatterPlotter().test_literal_attribute_vectors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestScatterPlotter(SharedAxesLevelTests, Helpers):\n    def test_size_norm_extrapolation(self):\n        x = np.arange(0, 20, 2)\n        f, axs = plt.subplots(1, 2, sharex=True, sharey=True)\n        slc = 5\n        kws = dict(sizes=(50, 200), size_norm=(0, x.max()), legend='brief')\n        scatterplot(x=x, y=x, size=x, ax=axs[0], **kws)\n        scatterplot(x=x[:slc], y=x[:slc], size=x[:slc], ax=axs[1], **kws)\n        assert np.allclose(axs[0].collections[0].get_sizes()[:slc], axs[1].\n            collections[0].get_sizes())\n        legends = [ax.legend_ for ax in axs]\n        legend_data = [{label.get_text(): handle.get_markersize() for label,\n            handle in zip(legend.get_texts(), get_legend_handles(legend))} for\n            legend in legends]\n        for key in (set(legend_data[0]) & set(legend_data[1])):\n            if key == 'y':\n                continue\n            assert legend_data[0][key] == legend_data[1][key]\n    \nTestScatterPlotter().test_size_norm_extrapolation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef scatterplot(data=None, *, x=None, y=None, hue=None, size=None, style=\n    None, palette=None, hue_order=None, hue_norm=None, sizes=None,\n    size_order=None, size_norm=None, markers=True, style_order=None, legend\n    ='auto', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided\")\n    \n    # Prepare the data for plotting\n    if orient == 'x':\n        data = data[[x, y, hue, size, style]].dropna()\n    else:\n        data = data[[y, x, hue, size, style]].dropna()\n    \n    # Group data by the specified parameters\n    grouped_data = data.groupby([x, hue, size, style]).agg({y: estimator}).reset_index()\n    \n    # Create the line plot\n    for key, grp in grouped_data.groupby(hue):\n        ax = grp.plot(x=x, y=y, ax=ax, label=key, **kwargs)\n    \n    # Handle error bars if specified\n    if errorbar is not None:\n        # Calculate error bars based on the specified method\n        # This is a placeholder for actual error bar calculation logic\n        pass\n\n    # Customize the plot with additional parameters\n    if legend == 'auto':\n        ax.legend()\n    \n    # Set additional properties\n    ax.set_xlabel(x)\n    ax.set_ylabel(y)\n    \n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided\")\n    \n    # Prepare the data for plotting\n    if orient == 'x':\n        data = data[[x, y, hue, size, style]].dropna()\n    else:\n        data = data[[y, x, hue, size, style]].dropna()\n    \n    # Group the data based on the specified parameters\n    grouped_data = data.groupby([x, hue, size, style]).agg(estimator).reset_index()\n    \n    # Create the line plot\n    if ax is None:\n        ax = plt.gca()\n    \n    # Plotting the lines\n    for key, grp in grouped_data.groupby(hue):\n        ax.plot(grp[x], grp[y], label=key, **kwargs)\n    \n    # Handle error bars if specified\n    if errorbar is not None:\n        # Calculate error bars based on the specified method\n        # Placeholder for error bar calculation logic\n        pass\n    \n    # Set legend if required\n    if legend == 'auto':\n        ax.legend()\n    \n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    # Prepare the data for plotting\n    grouped_data = data.groupby([x, hue, size, style]).agg({y: estimator}).reset_index()\n    \n    # Create the line plot\n    if ax is None:\n        ax = plt.gca()\n    \n    # Plotting logic\n    for key, grp in grouped_data.groupby(hue):\n        ax.plot(grp[x], grp[y], label=key, **kwargs)\n    \n    # Handle error bars if specified\n    if errorbar is not None:\n        # Calculate and plot error bars here (this is a placeholder)\n        pass\n    \n    # Set legend if required\n    if legend == 'auto':\n        ax.legend()\n    \n    # Set additional properties\n    ax.set_xlabel(x)\n    ax.set_ylabel(y)\n    \n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None or x is None or y is None:\n        raise ValueError(\"Data, x, and y must be provided.\")\n    \n    # Prepare the data for plotting\n    if orient == 'x':\n        data = data[[x, y, hue, size, style]].dropna()\n    else:\n        data = data[[y, x, hue, size, style]].dropna()\n    \n    # Group the data by the specified parameters and apply the estimator\n    grouped_data = data.groupby([x, hue, size, style]).agg({y: estimator}).reset_index()\n    \n    # Create the line plot\n    for key, grp in grouped_data.groupby(hue):\n        ax = grp.plot(x=x, y=y, ax=ax, label=key, **kwargs)\n    \n    # Handle error bars if specified\n    if errorbar is not None:\n        # Calculate error bars based on the specified method\n        # This is a placeholder for actual error bar calculation\n        # You would implement the logic to calculate error bars here\n        pass\n    \n    # Set additional plot properties\n    if legend == 'auto':\n        ax.legend()\n    \n    # Return the axes object\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "lineplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/relational.py", "response": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs):\n    \n    # Validate input data\n    if data is None:\n        raise ValueError(\"Data must be provided.\")\n    \n    # Prepare the data for plotting\n    if orient == 'x':\n        data = data[[x, y, hue, size, style]].dropna()\n    else:\n        data = data[[y, x, hue, size, style]].dropna()\n    \n    # Group the data by the specified parameters\n    grouped_data = data.groupby([x, hue, size, style]).agg({y: estimator}).reset_index()\n    \n    # Create the line plot\n    if ax is None:\n        ax = plt.gca()\n    \n    # Plotting logic\n    for key, grp in grouped_data.groupby(hue):\n        ax.plot(grp[x], grp[y], label=key, **kwargs)\n    \n    # Handle error bars if specified\n    if errorbar is not None:\n        # Calculate error bars based on the specified method\n        # This is a placeholder for actual error bar calculation\n        pass\n    \n    # Set legend if required\n    if legend == 'auto':\n        ax.legend()\n    \n    # Return the axis object\n    return ax", "test_code_list": [{"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    @pytest.mark.parametrize('var', ['hue', 'size'])\n    def test_legend_binary_var(self):\n        x, y = np.random.randn(2, 40)\n        z = np.tile(np.arange(20), 2)\n        ax = lineplot(x=x, y=y, hue=z % 2)\n        _, labels = ax.get_legend_handles_labels()\n        assert labels == ['0', '1']\n    \nTestLinePlotter().test_legend_binary_var()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_non_aggregated_data(self):\n        x = [1, 2, 3, 4]\n        y = [2, 4, 6, 8]\n        ax = lineplot(x=x, y=y)\n        line, = ax.lines\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n    \nTestLinePlotter().test_non_aggregated_data()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_log_scale(self):\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        x = [1, 10, 100]\n        y = [1, 2, 3]\n        lineplot(x=x, y=y)\n        line = ax.lines[0]\n        assert_array_equal(line.get_xdata(), x)\n        assert_array_equal(line.get_ydata(), y)\n        f, ax = plt.subplots()\n        ax.set_xscale('log')\n        ax.set_yscale('log')\n        x = [1, 1, 2, 2]\n        y = [1, 10, 1, 100]\n        lineplot(x=x, y=y, err_style='bars', errorbar=('pi', 100))\n        line = ax.lines[0]\n        assert line.get_ydata()[1] == 10\n        ebars = ax.collections[0].get_segments()\n        assert_array_equal(ebars[0][:, 1], y[:2])\n        assert_array_equal(ebars[1][:, 1], y[2:])\n    \nTestLinePlotter().test_log_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}, {"test_code": "from itertools import product\nimport warnings\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn.palettes import color_palette\nfrom seaborn._base import categorical_order\nfrom seaborn._base import unique_markers\nfrom seaborn.relational import _RelationalPlotter\nfrom seaborn.relational import _LinePlotter\nfrom seaborn.relational import _ScatterPlotter\nfrom seaborn.relational import relplot\nfrom seaborn.relational import lineplot\nfrom seaborn.relational import scatterplot\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nclass Helpers:\n\n    @pytest.fixture\n    def levels(self, long_df):\n        return {var: categorical_order(long_df[var]) for var in ['a', 'b']}\n\n    def scatter_rgbs(self, collections):\n        rgbs = []\n        for col in collections:\n            rgb = tuple(col.get_facecolor().squeeze()[:3])\n            rgbs.append(rgb)\n        return rgbs\n\n    def paths_equal(self, *args):\n        equal = all([(len(a) == len(args[0])) for a in args])\n        for p1, p2 in zip(*args):\n            equal &= np.array_equal(p1.vertices, p2.vertices)\n            equal &= np.array_equal(p1.codes, p2.codes)\n        return equal\nclass SharedAxesLevelTests:\n\n    def test_color(self, long_df):\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C0')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        self.func(data=long_df, x='x', y='y', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C1')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', color='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n        ax = plt.figure().subplots()\n        self.func(data=long_df, x='x', y='y', c='C2', ax=ax)\n        assert self.get_last_color(ax) == to_rgba('C2')\n\nclass TestLinePlotter(SharedAxesLevelTests, Helpers):\n    def test_nonmapped_dashes(self):\n        ax = lineplot(x=[1, 2], y=[1, 2], dashes=(2, 1))\n        line = ax.lines[0]\n        assert line.get_linestyle() == '--'\n    \nTestLinePlotter().test_nonmapped_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_relational.py"}], "method_code_mask": "from functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.cbook import normalize_kwargs\n\n\ndef lineplot(data=None, *, x=None, y=None, hue=None, size=None, style=None,\n    units=None, weights=None, palette=None, hue_order=None, hue_norm=None,\n    sizes=None, size_order=None, size_norm=None, dashes=True, markers=None,\n    style_order=None, estimator='mean', errorbar=('ci', 95), n_boot=1000,\n    seed=None, orient='x', sort=True, err_style='band', err_kws=None,\n    legend='auto', ci='deprecated', ax=None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n):\n    # Define a list of marker styles\n    marker_styles = [\n        'o', 's', 'D', '^', 'v', '<', '>', 'p', '*', 'h', '+', 'x', '|', '_'\n    ]\n    \n    # Ensure we only return unique markers and fill them\n    markers = [f'{marker}' for marker in marker_styles[:n]]\n    \n    return markers", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n):\n    # Define a list of filled marker styles available in matplotlib\n    filled_markers = ['o', 's', 'D', '^', 'v', '<', '>', 'p', '*', 'h', '+', 'x', '|', '_']\n    \n    # Ensure we only return the number of unique markers requested\n    markers = filled_markers[:n] if n <= len(filled_markers) else filled_markers * (n // len(filled_markers)) + filled_markers[:n % len(filled_markers)]\n    \n    return markers", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n):\n    # Define a list of marker styles available in matplotlib\n    available_markers = [\n        'o', 's', 'D', '^', 'v', '<', '>', 'p', '*', 'h', '+', 'x', '|', '_'\n    ]\n    \n    # Ensure we only return unique markers up to the requested number\n    markers = available_markers[:n]\n    \n    # If n is greater than the number of available markers, raise a warning\n    if n > len(available_markers):\n        warnings.warn(f\"Requested {n} markers, but only {len(available_markers)} unique markers are available.\")\n    \n    return markers", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n):\n    # Define a list of marker styles that are filled\n    filled_markers = ['o', 's', 'D', '^', 'v', '<', '>', 'p', '*', 'h', '+', 'x', '|', '_']\n    \n    # Ensure we only return 'n' unique markers\n    markers = filled_markers[:n]\n    \n    return markers", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_markers", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n):\n    # Define a list of filled marker styles available in matplotlib\n    filled_markers = ['o', 's', 'D', '^', 'v', '<', '>', 'p', '*', 'h', '+', 'x', '|', '_']\n    \n    # Ensure we only return unique markers up to the requested number\n    markers = filled_markers[:n] if n <= len(filled_markers) else filled_markers + ['o'] * (n - len(filled_markers))\n    \n    return markers", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_markers(self):\n        n = 24\n        markers = unique_markers(n)\n        assert len(markers) == n\n        assert len(set(markers)) == n\n        for m in markers:\n            assert mpl.markers.MarkerStyle(m).is_filled()\n    \nTestCoreFunc().test_unique_markers()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_markers(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name: str) -> mpl.colors.Colormap:\n    if _version_predates(mpl.__version__, \"3.6\"):\n        # For versions prior to 3.6, use the old method to get colormap\n        return mpl.cm.get_cmap(name)\n    else:\n        # For versions 3.6 and above, use the new method to get colormap\n        return mpl.colormaps[name]", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name: str) -> mpl.colors.Colormap:\n    if _version_predates(mpl.__version__, \"3.6\"):\n        # For versions prior to 3.6, use the old method to get colormap\n        return mpl.cm.get_cmap(name)\n    else:\n        # For versions 3.6 and later, use the new method to get colormap\n        return mpl.colormaps[name]", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name: str) -> mpl.colors.Colormap:\n    if _version_predates(mpl.__version__, \"3.6\"):\n        return mpl.cm.get_cmap(name)\n    else:\n        return mpl.colormaps[name]", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name: str) -> mpl.colors.Colormap:\n    if _version_predates(mpl.__version__, \"3.6\"):\n        return mpl.cm.get_cmap(name)\n    else:\n        return mpl.colormaps[name]", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "get_colormap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_compat.py", "response": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name: str) -> mpl.colors.Colormap:\n    if _version_predates(mpl.__version__, \"3.6\"):\n        return mpl.cm.get_cmap(name)\n    else:\n        return mpl.colormaps[name]", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = palettes.mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = palettes.mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "from __future__ import annotations\nfrom typing import Literal\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.figure import Figure\nfrom seaborn.utils import _version_predates\n\n\ndef get_colormap(name): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n):\n    dashes = ['']  # Start with a solid line\n    # Generate unique dash patterns\n    for i in range(1, n):\n        # Create a pattern of long and short dashes\n        long_dash = 5 * i\n        short_dash = 2 * i\n        dashes.append((long_dash, short_dash))\n    return dashes", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n):\n    dashes = ['']  # Start with a solid line\n    # Generate unique dash patterns\n    for i in range(1, n):\n        # Create a pattern of long and short dashes\n        long_dash = 5 * i  # Length of long dash\n        short_dash = 2 * i  # Length of short dash\n        dashes.append((long_dash, short_dash))\n    return dashes", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n):\n    dashes = ['']  # Start with a solid line\n    # Generate unique dash patterns\n    for i in range(1, n):\n        # Create a pattern of long and short dashes\n        long_dash = 5 * i  # Length of long dash\n        short_dash = 2 * i  # Length of short dash\n        dashes.append((long_dash, short_dash))\n    return dashes", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n):\n    dashes = ['']  # Start with a solid line\n    # Generate unique dash patterns\n    for i in range(1, n):\n        # Create a pattern of long and short dashes\n        long_dash = 5 * i\n        short_dash = 2 * i\n        dashes.append((long_dash, short_dash))\n    return dashes", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "unique_dashes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n):\n    dashes = ['']  # Start with a solid line\n    # Generate unique dash patterns\n    for i in range(1, n):\n        # Create a pattern with alternating long and short dashes\n        long_dash = 5  # Length of long dash\n        short_dash = 2  # Length of short dash\n        pattern = (long_dash, short_dash) * (i // 2) + (long_dash,) * (i % 2)\n        dashes.append(tuple(pattern))\n    return dashes", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_unique_dashes(self):\n        n = 24\n        dashes = unique_dashes(n)\n        assert len(dashes) == n\n        assert len(set(dashes)) == n\n        assert dashes[0] == ''\n        for spec in dashes[1:]:\n            assert isinstance(spec, tuple)\n            assert not len(spec) % 2\n    \nTestCoreFunc().test_unique_dashes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef unique_dashes(n): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'):\n    if isinstance(vector, pd.Series):\n        vector = vector.to_numpy()\n    \n    if isinstance(vector, np.ndarray) or isinstance(vector, list):\n        if all(isinstance(x, (int, float, np.number)) for x in vector if pd.notna(x)):\n            return 'numeric'\n        elif all(isinstance(x, (str, bytes)) for x in vector if pd.notna(x)):\n            return 'categorical'\n        elif all(isinstance(x, (datetime, np.datetime64)) for x in vector if pd.notna(x)):\n            return 'datetime'\n        elif boolean_type == 'numeric' and all(x in [0, 1, np.nan] for x in vector):\n            return 'numeric'\n        else:\n            return 'categorical'\n    return 'categorical'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'):\n    if isinstance(vector, pd.Series):\n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return 'datetime'\n        if boolean_type == 'numeric' and all((x in [0, 1, np.nan] for x in vector)):\n            return 'numeric'\n        if pd.api.types.is_numeric_dtype(vector):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, np.ndarray):\n        if np.issubdtype(vector.dtype, np.datetime64):\n            return 'datetime'\n        if boolean_type == 'numeric' and np.all(np.isin(vector, [0, 1, np.nan])):\n            return 'numeric'\n        if np.issubdtype(vector.dtype, np.number):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, (list, tuple)):\n        if all(isinstance(x, (int, float, complex)) for x in vector if x is not None):\n            return 'numeric'\n        if all(isinstance(x, str) for x in vector):\n            return 'categorical'\n        return 'categorical'\n    \n    return 'categorical'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'):\n    if isinstance(vector, pd.Series):\n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return 'datetime'\n        if boolean_type == 'numeric' and all((x in [0, 1, np.nan] for x in vector)):\n            return 'numeric'\n        if pd.api.types.is_numeric_dtype(vector):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, np.ndarray):\n        if np.issubdtype(vector.dtype, np.datetime64):\n            return 'datetime'\n        if boolean_type == 'numeric' and np.all(np.isin(vector, [0, 1, np.nan])):\n            return 'numeric'\n        if np.issubdtype(vector.dtype, np.number):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, (list, tuple)):\n        if all(isinstance(x, (int, float, complex)) for x in vector if x is not None):\n            return 'numeric'\n        if all(isinstance(x, str) for x in vector):\n            return 'categorical'\n        return 'categorical'\n    \n    return 'categorical'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'):\n    if isinstance(vector, pd.Series):\n        vector = vector.values\n\n    if isinstance(vector, np.ndarray) or isinstance(vector, Sequence):\n        if np.issubdtype(vector.dtype, np.number):\n            return 'numeric'\n        elif np.issubdtype(vector.dtype, np.datetime64):\n            return 'datetime'\n        elif all(isinstance(x, (str, bytes)) for x in vector):\n            return 'categorical'\n        elif all(isinstance(x, Number) or pd.isna(x) for x in vector):\n            if boolean_type == 'numeric' and all(x in [0, 1, np.nan] for x in vector):\n                return 'numeric'\n            return 'numeric'\n        else:\n            return 'categorical'\n    return 'categorical'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'):\n    if isinstance(vector, pd.Series):\n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return 'datetime'\n        if boolean_type == 'numeric' and all((x in [0, 1, np.nan] for x in vector)):\n            return 'numeric'\n        if pd.api.types.is_numeric_dtype(vector):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, np.ndarray):\n        if np.issubdtype(vector.dtype, np.datetime64):\n            return 'datetime'\n        if boolean_type == 'numeric' and np.all(np.isin(vector, [0, 1, np.nan])):\n            return 'numeric'\n        if np.issubdtype(vector.dtype, np.number):\n            return 'numeric'\n        return 'categorical'\n    \n    if isinstance(vector, (list, tuple)):\n        if all(isinstance(x, (datetime, np.datetime64)) for x in vector):\n            return 'datetime'\n        if boolean_type == 'numeric' and all(x in [0, 1, None] for x in vector):\n            return 'numeric'\n        if all(isinstance(x, (Number, np.number)) for x in vector):\n            return 'numeric'\n        return 'categorical'\n    \n    return 'categorical'", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_variable_type(self):\n        s = pd.Series([1.0, 2.0, 3.0])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s.astype(int)) == 'numeric'\n        assert variable_type(s.astype(object)) == 'numeric'\n        assert variable_type(s.to_numpy()) == 'numeric'\n        assert variable_type(s.to_list()) == 'numeric'\n        s = pd.Series([1, 2, 3, np.nan], dtype=object)\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([np.nan, np.nan])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([pd.NA, pd.NA])\n        assert variable_type(s) == 'numeric'\n        s = pd.Series([1, 2, pd.NA], dtype='Int64')\n        assert variable_type(s) == 'numeric'\n        s = pd.Series(['1', '2', '3'])\n        assert variable_type(s) == 'categorical'\n        assert variable_type(s.to_numpy()) == 'categorical'\n        assert variable_type(s.to_list()) == 'categorical'\n        s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n        assert variable_type(s) == 'categorical'\n        s = pd.Series([True, False, False])\n        assert variable_type(s) == 'numeric'\n        assert variable_type(s, boolean_type='categorical') == 'categorical'\n        s_cat = s.astype('category')\n        assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n        assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n        s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n        assert variable_type(s) == 'datetime'\n        assert variable_type(s.astype(object)) == 'datetime'\n        assert variable_type(s.to_numpy()) == 'datetime'\n        assert variable_type(s.to_list()) == 'datetime'\n    \nTestCoreFunc().test_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef variable_type(vector, boolean_type='numeric'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    if orient is not None:\n        if orient in [\"x\", \"y\"] or orient.startswith(\"v\") or orient.startswith(\"h\"):\n            return \"y\" if orient.startswith(\"v\") or orient == \"y\" else \"x\"\n        else:\n            raise ValueError(\"Unknown orientation string: {}\".format(orient))\n\n    if x is not None and y is not None:\n        raise ValueError(\"Both x and y cannot be provided for orientation inference.\")\n    \n    if x is not None:\n        orient = \"h\"\n    elif y is not None:\n        orient = \"v\"\n    else:\n        raise ValueError(\"At least one of x or y must be provided.\")\n\n    if require_numeric and orient == \"v\":\n        if not isinstance(y, (np.ndarray, pd.Series)) or not np.issubdtype(y.dtype, np.number):\n            raise TypeError(\"Dependent variable y must be numeric.\")\n\n    if require_numeric and orient == \"h\":\n        if not isinstance(x, (np.ndarray, pd.Series)) or not np.issubdtype(x.dtype, np.number):\n            raise TypeError(\"Dependent variable x must be numeric.\")\n\n    return \"y\" if orient == \"v\" else \"x\"", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    if orient is not None:\n        if orient in [\"x\", \"y\"] or orient.startswith(\"v\") or orient.startswith(\"h\"):\n            return \"y\" if orient in [\"y\", \"v\"] else \"x\"\n        else:\n            raise ValueError(\"Unknown orientation string: {}\".format(orient))\n\n    if x is not None and y is not None:\n        raise ValueError(\"Both x and y cannot be provided for orientation inference.\")\n\n    if y is not None:\n        if require_numeric and not isinstance(y, (np.ndarray, pd.Series)) or not np.issubdtype(type(y), np.number):\n            raise TypeError(\"The dependent variable y must be numeric.\")\n        return \"y\"\n    \n    if x is not None:\n        if require_numeric and not isinstance(x, (np.ndarray, pd.Series)) or not np.issubdtype(type(x), np.number):\n            raise TypeError(\"The dependent variable x must be numeric.\")\n        return \"x\"\n\n    raise ValueError(\"At least one of x or y must be provided.\")", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    if orient is not None:\n        if orient in ['x', 'y'] or orient.startswith(('v', 'h')):\n            return 'y' if orient.startswith('v') else 'x'\n        else:\n            raise ValueError(f\"Unknown orientation: {orient}\")\n\n    if x is not None and y is not None:\n        if isinstance(x, (pd.Series, np.ndarray)) and isinstance(y, (pd.Series, np.ndarray)):\n            if np.issubdtype(np.asarray(y).dtype, np.number):\n                return 'y'\n            else:\n                if require_numeric:\n                    raise TypeError(\"Dependent variable 'y' must be numeric.\")\n                return 'x'\n        else:\n            raise TypeError(\"Both x and y must be array-like.\")\n\n    if x is not None:\n        return 'x'\n    elif y is not None:\n        return 'y'\n    else:\n        raise ValueError(\"At least one of x or y must be provided.\")", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    if orient is not None:\n        if orient in [\"x\", \"y\"] or orient.startswith(\"v\") or orient.startswith(\"h\"):\n            return \"y\" if orient in [\"y\", \"v\"] else \"x\"\n        else:\n            raise ValueError(f\"Unknown orientation: {orient}\")\n\n    if x is not None and y is not None:\n        raise ValueError(\"Both x and y cannot be provided to infer orientation.\")\n\n    if x is not None:\n        if require_numeric and not isinstance(x, (np.ndarray, pd.Series)) and not all(isinstance(i, Number) for i in x):\n            raise TypeError(\"The x variable must be numeric.\")\n        return \"x\"\n    \n    if y is not None:\n        if require_numeric and not isinstance(y, (np.ndarray, pd.Series)) and not all(isinstance(i, Number) for i in y):\n            raise TypeError(\"The y variable must be numeric.\")\n        return \"y\"\n\n    raise ValueError(\"At least one of x or y must be provided.\")", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "infer_orient", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_base.py", "response": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True):\n    if orient is not None:\n        if orient in [\"x\", \"y\"] or orient.startswith(\"v\") or orient.startswith(\"h\"):\n            return \"y\" if orient.startswith(\"v\") else \"x\"\n        else:\n            raise ValueError(\"Unknown orientation string: {}\".format(orient))\n\n    if x is not None and y is not None:\n        if isinstance(x, (pd.Series, np.ndarray)) and isinstance(y, (pd.Series, np.ndarray)):\n            if np.issubdtype(np.asarray(y).dtype, np.number):\n                return \"y\"\n            else:\n                if require_numeric:\n                    raise TypeError(\"Dependent variable 'y' must be numeric.\")\n                return \"x\"\n        else:\n            raise TypeError(\"Both x and y must be vector-like objects.\")\n\n    if x is not None:\n        return \"x\"\n    elif y is not None:\n        return \"y\"\n    else:\n        raise ValueError(\"At least one of x or y must be provided.\")", "test_code_list": [{"test_code": "import itertools\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom pandas.testing import assert_frame_equal\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn._compat import get_colormap\nfrom seaborn._base import SemanticMapping\nfrom seaborn._base import HueMapping\nfrom seaborn._base import SizeMapping\nfrom seaborn._base import StyleMapping\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import variable_type\nfrom seaborn._base import infer_orient\nfrom seaborn._base import unique_dashes\nfrom seaborn._base import unique_markers\nfrom seaborn._base import categorical_order\nfrom seaborn.utils import desaturate\nfrom seaborn.palettes import color_palette\n\nclass TestCoreFunc():\n    def test_infer_orient(self):\n        nums = pd.Series(np.arange(6))\n        cats = pd.Series(['a', 'b'] * 3)\n        dates = pd.date_range('1999-09-22', '2006-05-14', 6)\n        assert infer_orient(cats, nums) == 'x'\n        assert infer_orient(nums, cats) == 'y'\n        assert infer_orient(cats, dates, require_numeric=False) == 'x'\n        assert infer_orient(dates, cats, require_numeric=False) == 'y'\n        assert infer_orient(nums, None) == 'y'\n        with pytest.warns(UserWarning, match='Vertical .+ `x`'):\n            assert infer_orient(nums, None, 'v') == 'y'\n        assert infer_orient(None, nums) == 'x'\n        with pytest.warns(UserWarning, match='Horizontal .+ `y`'):\n            assert infer_orient(None, nums, 'h') == 'x'\n        infer_orient(cats, None, require_numeric=False) == 'y'\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, None)\n        infer_orient(cats, None, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(None, cats)\n        assert infer_orient(nums, nums, 'vert') == 'x'\n        assert infer_orient(nums, nums, 'hori') == 'y'\n        assert infer_orient(cats, cats, 'h', require_numeric=False) == 'y'\n        assert infer_orient(cats, cats, 'v', require_numeric=False) == 'x'\n        assert infer_orient(cats, cats, require_numeric=False) == 'x'\n        with pytest.raises(TypeError, match='Vertical .+ `y`'):\n            infer_orient(cats, cats, 'x')\n        with pytest.raises(TypeError, match='Horizontal .+ `x`'):\n            infer_orient(cats, cats, 'y')\n        with pytest.raises(TypeError, match='Neither'):\n            infer_orient(cats, cats)\n        with pytest.raises(ValueError, match='`orient` must start with'):\n            infer_orient(cats, nums, orient='bad value')\n    \nTestCoreFunc().test_infer_orient()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_base.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nimport itertools\nfrom copy import copy\nfrom collections import UserString\nfrom collections.abc import Iterable\nfrom collections.abc import Sequence\nfrom collections.abc import Mapping\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom seaborn._core.data import PlotData\nfrom seaborn.palettes import QUAL_PALETTES\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import locator_to_legend_entries\nfrom seaborn.utils import get_color_cycle\nfrom seaborn.utils import remove_na\n\n\ndef infer_orient(x=None, y=None, orient=None, require_numeric=True): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None):\n    if context is None:\n        return _PlottingContext()\n\n    if isinstance(context, str):\n        context = context.lower()\n        if context == 'paper':\n            context = {'font.size': 10 * font_scale, 'axes.labelsize': 10 * font_scale,\n                        'axes.titlesize': 12 * font_scale, 'xtick.labelsize': 8 * font_scale,\n                        'ytick.labelsize': 8 * font_scale, 'legend.fontsize': 8 * font_scale,\n                        'legend.title_fontsize': 10 * font_scale, 'axes.linewidth': 1.5,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1.5, 'lines.markersize': 6,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 5, 'ytick.major.size': 5,\n                        'xtick.minor.size': 3, 'ytick.minor.size': 3}\n        elif context == 'notebook':\n            context = {'font.size': 12 * font_scale, 'axes.labelsize': 12 * font_scale,\n                        'axes.titlesize': 14 * font_scale, 'xtick.labelsize': 10 * font_scale,\n                        'ytick.labelsize': 10 * font_scale, 'legend.fontsize': 10 * font_scale,\n                        'legend.title_fontsize': 12 * font_scale, 'axes.linewidth': 1,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1, 'lines.markersize': 8,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 5, 'ytick.major.size': 5,\n                        'xtick.minor.size': 3, 'ytick.minor.size': 3}\n        elif context == 'talk':\n            context = {'font.size': 14 * font_scale, 'axes.labelsize': 14 * font_scale,\n                        'axes.titlesize': 16 * font_scale, 'xtick.labelsize': 12 * font_scale,\n                        'ytick.labelsize': 12 * font_scale, 'legend.fontsize': 12 * font_scale,\n                        'legend.title_fontsize': 14 * font_scale, 'axes.linewidth': 2,\n                        'grid.linewidth': 1, 'lines.linewidth': 2, 'lines.markersize': 10,\n                        'patch.linewidth': 1, 'xtick.major.width': 1.5, 'ytick.major.width': 1.5,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 7, 'ytick.major.size': 7,\n                        'xtick.minor.size': 4, 'ytick.minor.size': 4}\n        elif context == 'poster':\n            context = {'font.size': 18 * font_scale, 'axes.labelsize': 18 * font_scale,\n                        'axes.titlesize': 20 * font_scale, 'xtick.labelsize': 16 * font_scale,\n                        'ytick.labelsize': 16 * font_scale, 'legend.fontsize': 16 * font_scale,\n                        'legend.title_fontsize': 18 * font_scale, 'axes.linewidth': 3,\n                        'grid.linewidth': 1.5, 'lines.linewidth': 3, 'lines.markersize': 12,\n                        'patch.linewidth': 1.5, 'xtick.major.width': 2, 'ytick.major.width': 2,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 10, 'ytick.major.size': 10,\n                        'xtick.minor.size': 5, 'ytick.minor.size': 5}\n        else:\n            raise ValueError(f\"Unknown context: {context}\")\n\n    if rc is not None:\n        context.update(rc)\n\n    return _PlottingContext(context)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None):\n    if context is None:\n        return _PlottingContext()\n\n    if isinstance(context, str):\n        context = context.lower()\n        if context == 'paper':\n            context = {'font.size': 10 * font_scale, 'axes.labelsize': 10 * font_scale,\n                        'axes.titlesize': 12 * font_scale, 'xtick.labelsize': 8 * font_scale,\n                        'ytick.labelsize': 8 * font_scale, 'legend.fontsize': 8 * font_scale,\n                        'legend.title_fontsize': 10 * font_scale, 'axes.linewidth': 1,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1, 'lines.markersize': 6,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 4, 'ytick.major.size': 4,\n                        'xtick.minor.size': 2, 'ytick.minor.size': 2}\n        elif context == 'notebook':\n            context = {'font.size': 12 * font_scale, 'axes.labelsize': 12 * font_scale,\n                        'axes.titlesize': 14 * font_scale, 'xtick.labelsize': 10 * font_scale,\n                        'ytick.labelsize': 10 * font_scale, 'legend.fontsize': 10 * font_scale,\n                        'legend.title_fontsize': 12 * font_scale, 'axes.linewidth': 1,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1, 'lines.markersize': 8,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 5, 'ytick.major.size': 5,\n                        'xtick.minor.size': 3, 'ytick.minor.size': 3}\n        elif context == 'talk':\n            context = {'font.size': 14 * font_scale, 'axes.labelsize': 14 * font_scale,\n                        'axes.titlesize': 16 * font_scale, 'xtick.labelsize': 12 * font_scale,\n                        'ytick.labelsize': 12 * font_scale, 'legend.fontsize': 12 * font_scale,\n                        'legend.title_fontsize': 14 * font_scale, 'axes.linewidth': 1.5,\n                        'grid.linewidth': 1, 'lines.linewidth': 2, 'lines.markersize': 10,\n                        'patch.linewidth': 1, 'xtick.major.width': 1.5, 'ytick.major.width': 1.5,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 6, 'ytick.major.size': 6,\n                        'xtick.minor.size': 4, 'ytick.minor.size': 4}\n        elif context == 'poster':\n            context = {'font.size': 20 * font_scale, 'axes.labelsize': 20 * font_scale,\n                        'axes.titlesize': 24 * font_scale, 'xtick.labelsize': 18 * font_scale,\n                        'ytick.labelsize': 18 * font_scale, 'legend.fontsize': 18 * font_scale,\n                        'legend.title_fontsize': 20 * font_scale, 'axes.linewidth': 2,\n                        'grid.linewidth': 1, 'lines.linewidth': 2, 'lines.markersize': 12,\n                        'patch.linewidth': 1, 'xtick.major.width': 2, 'ytick.major.width': 2,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 8, 'ytick.major.size': 8,\n                        'xtick.minor.size': 6, 'ytick.minor.size': 6}\n        else:\n            raise ValueError(f\"Unknown context: {context}\")\n\n    if rc is not None:\n        context.update(rc)\n\n    return _PlottingContext(context)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None):\n    if context is None:\n        return _PlottingContext()\n\n    if isinstance(context, str):\n        context = context.lower()\n        if context == 'paper':\n            context = {'font.size': 10, 'axes.labelsize': 10, 'axes.titlesize': 12,\n                        'xtick.labelsize': 8, 'ytick.labelsize': 8, 'legend.fontsize': 8,\n                        'legend.title_fontsize': 10, 'axes.linewidth': 1, 'grid.linewidth': 0.5,\n                        'lines.linewidth': 1, 'lines.markersize': 6, 'patch.linewidth': 0.5,\n                        'xtick.major.width': 0.5, 'ytick.major.width': 0.5,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 5, 'ytick.major.size': 5,\n                        'xtick.minor.size': 3, 'ytick.minor.size': 3}\n        elif context == 'notebook':\n            context = {'font.size': 12, 'axes.labelsize': 12, 'axes.titlesize': 14,\n                        'xtick.labelsize': 10, 'ytick.labelsize': 10, 'legend.fontsize': 10,\n                        'legend.title_fontsize': 12, 'axes.linewidth': 1, 'grid.linewidth': 0.5,\n                        'lines.linewidth': 1, 'lines.markersize': 8, 'patch.linewidth': 1,\n                        'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 7, 'ytick.major.size': 7,\n                        'xtick.minor.size': 4, 'ytick.minor.size': 4}\n        elif context == 'talk':\n            context = {'font.size': 14, 'axes.labelsize': 14, 'axes.titlesize': 16,\n                        'xtick.labelsize': 12, 'ytick.labelsize': 12, 'legend.fontsize': 12,\n                        'legend.title_fontsize': 14, 'axes.linewidth': 1.5, 'grid.linewidth': 1,\n                        'lines.linewidth': 1.5, 'lines.markersize': 10, 'patch.linewidth': 1,\n                        'xtick.major.width': 1.5, 'ytick.major.width': 1.5,\n                        'xtick.minor.width': 1.5, 'ytick.minor.width': 1.5,\n                        'xtick.major.size': 8, 'ytick.major.size': 8,\n                        'xtick.minor.size': 5, 'ytick.minor.size': 5}\n        elif context == 'poster':\n            context = {'font.size': 18, 'axes.labelsize': 18, 'axes.titlesize': 20,\n                        'xtick.labelsize': 16, 'ytick.labelsize': 16, 'legend.fontsize': 16,\n                        'legend.title_fontsize': 18, 'axes.linewidth': 2, 'grid.linewidth': 1,\n                        'lines.linewidth': 2, 'lines.markersize': 12, 'patch.linewidth': 1,\n                        'xtick.major.width': 2, 'ytick.major.width': 2,\n                        'xtick.minor.width': 2, 'ytick.minor.width': 2,\n                        'xtick.major.size': 10, 'ytick.major.size': 10,\n                        'xtick.minor.size': 6, 'ytick.minor.size': 6}\n        else:\n            raise ValueError(f\"Unknown context: {context}\")\n\n    if rc is not None:\n        context.update(rc)\n\n    # Scale the context values by font_scale\n    return {key: value * font_scale for key, value in context.items()}", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None):\n    if context is None:\n        return _PlottingContext()\n\n    if isinstance(context, str):\n        context = context.lower()\n        if context == 'paper':\n            context = {'font.size': 10 * font_scale,\n                        'axes.labelsize': 10 * font_scale,\n                        'axes.titlesize': 12 * font_scale,\n                        'xtick.labelsize': 8 * font_scale,\n                        'ytick.labelsize': 8 * font_scale,\n                        'legend.fontsize': 8 * font_scale,\n                        'legend.title_fontsize': 10 * font_scale,\n                        'axes.linewidth': 1 * font_scale,\n                        'grid.linewidth': 0.5 * font_scale,\n                        'lines.linewidth': 1 * font_scale,\n                        'lines.markersize': 6 * font_scale,\n                        'patch.linewidth': 0.5 * font_scale,\n                        'xtick.major.width': 0.5 * font_scale,\n                        'ytick.major.width': 0.5 * font_scale,\n                        'xtick.minor.width': 0.5 * font_scale,\n                        'ytick.minor.width': 0.5 * font_scale,\n                        'xtick.major.size': 4 * font_scale,\n                        'ytick.major.size': 4 * font_scale,\n                        'xtick.minor.size': 2 * font_scale,\n                        'ytick.minor.size': 2 * font_scale}\n        elif context == 'notebook':\n            context = {'font.size': 12 * font_scale,\n                        'axes.labelsize': 12 * font_scale,\n                        'axes.titlesize': 14 * font_scale,\n                        'xtick.labelsize': 10 * font_scale,\n                        'ytick.labelsize': 10 * font_scale,\n                        'legend.fontsize': 10 * font_scale,\n                        'legend.title_fontsize': 12 * font_scale,\n                        'axes.linewidth': 1 * font_scale,\n                        'grid.linewidth': 0.5 * font_scale,\n                        'lines.linewidth': 1 * font_scale,\n                        'lines.markersize': 8 * font_scale,\n                        'patch.linewidth': 0.5 * font_scale,\n                        'xtick.major.width': 0.5 * font_scale,\n                        'ytick.major.width': 0.5 * font_scale,\n                        'xtick.minor.width': 0.5 * font_scale,\n                        'ytick.minor.width': 0.5 * font_scale,\n                        'xtick.major.size': 5 * font_scale,\n                        'ytick.major.size': 5 * font_scale,\n                        'xtick.minor.size': 3 * font_scale,\n                        'ytick.minor.size': 3 * font_scale}\n        elif context == 'talk':\n            context = {'font.size': 14 * font_scale,\n                        'axes.labelsize': 14 * font_scale,\n                        'axes.titlesize': 16 * font_scale,\n                        'xtick.labelsize': 12 * font_scale,\n                        'ytick.labelsize': 12 * font_scale,\n                        'legend.fontsize': 12 * font_scale,\n                        'legend.title_fontsize': 14 * font_scale,\n                        'axes.linewidth': 1.5 * font_scale,\n                        'grid.linewidth': 1 * font_scale,\n                        'lines.linewidth': 1.5 * font_scale,\n                        'lines.markersize': 10 * font_scale,\n                        'patch.linewidth': 1 * font_scale,\n                        'xtick.major.width': 1 * font_scale,\n                        'ytick.major.width': 1 * font_scale,\n                        'xtick.minor.width': 1 * font_scale,\n                        'ytick.minor.width': 1 * font_scale,\n                        'xtick.major.size': 6 * font_scale,\n                        'ytick.major.size': 6 * font_scale,\n                        'xtick.minor.size': 4 * font_scale,\n                        'ytick.minor.size': 4 * font_scale}\n        elif context == 'poster':\n            context = {'font.size': 20 * font_scale,\n                        'axes.labelsize': 20 * font_scale,\n                        'axes.titlesize': 24 * font_scale,\n                        'xtick.labelsize': 18 * font_scale,\n                        'ytick.labelsize': 18 * font_scale,\n                        'legend.fontsize': 18 * font_scale,\n                        'legend.title_fontsize': 20 * font_scale,\n                        'axes.linewidth': 2 * font_scale,\n                        'grid.linewidth': 1 * font_scale,\n                        'lines.linewidth': 2 * font_scale,\n                        'lines.markersize': 12 * font_scale,\n                        'patch.linewidth': 1 * font_scale,\n                        'xtick.major.width': 1 * font_scale,\n                        'ytick.major.width': 1 * font_scale,\n                        'xtick.minor.width': 1 * font_scale,\n                        'ytick.minor.width': 1 * font_scale,\n                        'xtick.major.size': 8 * font_scale,\n                        'ytick.major.size': 8 * font_scale,\n                        'xtick.minor.size': 5 * font_scale,\n                        'ytick.minor.size': 5 * font_scale}\n        else:\n            raise ValueError(\"Invalid context specified. Use one of: \"\n                             \"'paper', 'notebook', 'talk', 'poster'.\")\n\n    if rc is not None:\n        context.update(rc)\n\n    return _PlottingContext(context)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "plotting_context", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None):\n    if context is None:\n        return _PlottingContext()\n\n    if isinstance(context, str):\n        context = context.lower()\n        if context == 'paper':\n            context = {'font.size': 10 * font_scale, 'axes.labelsize': 10 * font_scale,\n                        'axes.titlesize': 12 * font_scale, 'xtick.labelsize': 8 * font_scale,\n                        'ytick.labelsize': 8 * font_scale, 'legend.fontsize': 8 * font_scale,\n                        'legend.title_fontsize': 10 * font_scale, 'axes.linewidth': 1,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1, 'lines.markersize': 6,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 4, 'ytick.major.size': 4,\n                        'xtick.minor.size': 2, 'ytick.minor.size': 2}\n        elif context == 'notebook':\n            context = {'font.size': 12 * font_scale, 'axes.labelsize': 12 * font_scale,\n                        'axes.titlesize': 14 * font_scale, 'xtick.labelsize': 10 * font_scale,\n                        'ytick.labelsize': 10 * font_scale, 'legend.fontsize': 10 * font_scale,\n                        'legend.title_fontsize': 12 * font_scale, 'axes.linewidth': 1,\n                        'grid.linewidth': 0.5, 'lines.linewidth': 1, 'lines.markersize': 8,\n                        'patch.linewidth': 0.5, 'xtick.major.width': 1, 'ytick.major.width': 1,\n                        'xtick.minor.width': 0.5, 'ytick.minor.width': 0.5,\n                        'xtick.major.size': 5, 'ytick.major.size': 5,\n                        'xtick.minor.size': 3, 'ytick.minor.size': 3}\n        elif context == 'talk':\n            context = {'font.size': 14 * font_scale, 'axes.labelsize': 14 * font_scale,\n                        'axes.titlesize': 16 * font_scale, 'xtick.labelsize': 12 * font_scale,\n                        'ytick.labelsize': 12 * font_scale, 'legend.fontsize': 12 * font_scale,\n                        'legend.title_fontsize': 14 * font_scale, 'axes.linewidth': 1.5,\n                        'grid.linewidth': 1, 'lines.linewidth': 2, 'lines.markersize': 10,\n                        'patch.linewidth': 1, 'xtick.major.width': 1.5, 'ytick.major.width': 1.5,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 6, 'ytick.major.size': 6,\n                        'xtick.minor.size': 4, 'ytick.minor.size': 4}\n        elif context == 'poster':\n            context = {'font.size': 20 * font_scale, 'axes.labelsize': 20 * font_scale,\n                        'axes.titlesize': 24 * font_scale, 'xtick.labelsize': 18 * font_scale,\n                        'ytick.labelsize': 18 * font_scale, 'legend.fontsize': 18 * font_scale,\n                        'legend.title_fontsize': 20 * font_scale, 'axes.linewidth': 2,\n                        'grid.linewidth': 1, 'lines.linewidth': 2, 'lines.markersize': 12,\n                        'patch.linewidth': 1, 'xtick.major.width': 2, 'ytick.major.width': 2,\n                        'xtick.minor.width': 1, 'ytick.minor.width': 1,\n                        'xtick.major.size': 8, 'ytick.major.size': 8,\n                        'xtick.minor.size': 6, 'ytick.minor.size': 6}\n        else:\n            raise ValueError(f\"Unknown context: {context}\")\n\n    if rc is not None:\n        context.update(rc)\n\n    return _PlottingContext(context)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_font_scale(self):\n        notebook_ref = plotting_context('notebook')\n        notebook_big = plotting_context('notebook', 2)\n        font_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n            'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n            'legend.title_fontsize']\n        for k in font_keys:\n            assert notebook_ref[k] * 2 == notebook_big[k]\n    \nTestPlottingContext().test_font_scale()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_rc_override(self):\n        key, val = 'grid.linewidth', 5\n        rc = {key: val, 'foo': 'bar'}\n        out = plotting_context('talk', rc=rc)\n        assert out[key] == val\n        assert 'foo' not in out\n    \nTestPlottingContext().test_rc_override()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPlottingContext(RCParamFixtures):\n    def test_context_context_manager(self):\n        rcmod.set_context('notebook')\n        orig_params = plotting_context()\n        context_params = plotting_context('paper')\n        with plotting_context('paper'):\n            self.assert_rc_params(context_params)\n        self.assert_rc_params(orig_params)\n    \n        @plotting_context('paper')\n        def func():\n            self.assert_rc_params(context_params)\n        func()\n        self.assert_rc_params(orig_params)\n    \nTestPlottingContext().test_context_context_manager()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_context(context=None, font_scale=1, rc=None):\n    \"\"\"\n    Set the parameters that control the scaling of plot elements.\n\n    These parameters correspond to label size, line thickness, etc.\n    Calling this function modifies the global matplotlib `rcParams`. For more\n    information, see the :doc:`aesthetics tutorial <../tutorial/aesthetics>`.\n\n    The base context is \"notebook\", and the other contexts are \"paper\", \"talk\",\n    and \"poster\", which are version of the notebook parameters scaled by different\n    values. Font elements can also be scaled independently of (but relative to)\n    the other values.\n\n    See :func:`plotting_context` to get the parameter values.\n\n    Parameters\n    ----------\n    context : dict, or one of {paper, notebook, talk, poster}\n        A dictionary of parameters or the name of a preconfigured set.\n    font_scale : float, optional\n        Separate scaling factor to independently scale the size of the\n        font elements.\n    rc : dict, optional\n        Parameter mappings to override the values in the preset seaborn\n        context dictionaries. This only updates parameters that are\n        considered part of the context definition.\n\n    Examples\n    --------\n\n    .. include:: ../docstrings/set_context.rst\n\n    \"\"\"\n    context_object = plotting_context(context, font_scale, rc)\n    mpl.rcParams.update(context_object)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\nclass _RCAesthetics(dict):\n\n    def __enter__(self):\n        rc = mpl.rcParams\n        self._orig = {k: rc[k] for k in self._keys}\n        self._set(self)\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        self._set(self._orig)\n\n    def __call__(self, func):\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            with self:\n                return func(*args, **kwargs)\n        return wrapper\n\n\nclass _PlottingContext(_RCAesthetics):\n    \"\"\"Light wrapper on a dict to set context temporarily.\"\"\"\n    _keys = _context_keys\n    _set = staticmethod(set_context)\n\n\n_context_keys = ['font.size', 'axes.labelsize', 'axes.titlesize',\n    'xtick.labelsize', 'ytick.labelsize', 'legend.fontsize',\n    'legend.title_fontsize', 'axes.linewidth', 'grid.linewidth',\n    'lines.linewidth', 'lines.markersize', 'patch.linewidth',\n    'xtick.major.width', 'ytick.major.width', 'xtick.minor.width',\n    'ytick.minor.width', 'xtick.major.size', 'ytick.major.size',\n    'xtick.minor.size', 'ytick.minor.size']\n\n\ndef plotting_context(context=None, font_scale=1, rc=None): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\nimport seaborn as sns\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    if isinstance(palette, str) and palette in ['hls', 'husl']:\n        # Use seaborn to generate a palette for hls or husl\n        palette = sns.color_palette(palette, n_colors)\n    elif isinstance(palette, str):\n        # Assume it's a seaborn palette name\n        palette = sns.color_palette(palette, n_colors)\n    elif callable(palette):\n        # Assume it's a matplotlib colormap\n        palette = [palette(i) for i in range(palette.N)]\n    else:\n        raise ValueError(\"Invalid palette type. Must be a seaborn palette name, a matplotlib colormap, or 'hls'/'husl'.\")\n\n    if desat is not None:\n        palette = sns.desaturate(palette, desat)\n\n    # Set the color cycle for matplotlib\n    mpl.rcParams['axes.prop_cycle'] = cycler(color=palette)\n\n    if color_codes and isinstance(palette, list):\n        # Remap shorthand color codes to the selected palette\n        color_map = {code: color for code, color in zip(sns.color_palette(\"deep\", len(palette)), palette)}\n        mpl.rcParams['axes.color_cycle'] = [color_map.get(c, c) for c in mpl.rcParams['axes.color_cycle']]", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\nimport seaborn as sns\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    if isinstance(palette, str) and palette in ['hls', 'husl']:\n        if n_colors is None:\n            n_colors = 6  # Default number of colors for hls/husl\n        colors = sns.color_palette(palette, n_colors)\n    else:\n        if isinstance(palette, list):\n            colors = palette\n        else:\n            colors = sns.color_palette(palette, n_colors)\n\n    if desat is not None:\n        colors = [sns.desaturate(color, desat) for color in colors]\n\n    mpl.rcParams['axes.prop_cycle'] = cycler(color=colors)\n\n    if color_codes and isinstance(palette, list):\n        for i, color in enumerate(colors):\n            mpl.colors.CSS4_COLORS[f'color{i}'] = mpl.colors.to_hex(color)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\nimport seaborn as sns\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    if isinstance(palette, str) and palette in ['hls', 'husl']:\n        if n_colors is None:\n            n_colors = 10  # Default number of colors for hls/husl\n        colors = sns.color_palette(palette, n_colors)\n    else:\n        if isinstance(palette, list):\n            colors = palette\n        else:\n            colors = sns.color_palette(palette, n_colors)\n\n    if desat is not None:\n        colors = [sns.desaturate(color, desat) for color in colors]\n\n    mpl.rcParams['axes.prop_cycle'] = cycler(color=colors)\n\n    if color_codes and isinstance(palette, (list, str)):\n        for i, color in enumerate(colors):\n            mpl.colors.CSS4_COLORS[f'c{i}'] = mpl.colors.to_hex(color)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\nimport seaborn as sns\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    if isinstance(palette, str) and palette in ['hls', 'husl']:\n        # Use seaborn's hls or husl palette\n        palette = sns.color_palette(palette, n_colors)\n    elif isinstance(palette, str):\n        # Assume it's a seaborn palette name\n        palette = sns.color_palette(palette, n_colors)\n    elif isinstance(palette, mpl.colors.Colormap):\n        # If it's a matplotlib colormap, get colors\n        palette = [palette(i) for i in range(palette.N)]\n    elif not isinstance(palette, (list, tuple)):\n        raise ValueError(\"Palette must be a seaborn palette, matplotlib colormap, or a string.\")\n\n    if n_colors is not None:\n        palette = palette[:n_colors]\n\n    if desat is not None:\n        palette = sns.desaturate(palette, desat)\n\n    # Set the color cycle for matplotlib\n    mpl.rcParams['axes.prop_cycle'] = cycler(color=palette)\n\n    if color_codes and isinstance(palette, list):\n        # Remap shorthand color codes to the selected palette\n        color_map = {code: color for code, color in zip(sns.color_palette(\"deep\", len(palette)), palette)}\n        mpl.rcParams['axes.prop_cycle'] = cycler(color=[color_map.get(c, c) for c in mpl.rcParams['axes.prop_cycle']])", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/rcmod.py", "response": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\nimport seaborn as sns\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False):\n    if isinstance(palette, str) and palette in ['hls', 'husl']:\n        if n_colors is None:\n            n_colors = 6  # Default number of colors for hls/husl\n        colors = sns.color_palette(palette, n_colors)\n    else:\n        if isinstance(palette, list):\n            colors = palette\n        else:\n            colors = sns.color_palette(palette, n_colors)\n\n    if desat is not None:\n        colors = [sns.desaturate(color, desat) for color in colors]\n\n    mpl.rcParams['axes.prop_cycle'] = cycler(color=colors)\n\n    if color_codes and isinstance(palette, list):\n        for i, color in enumerate(colors):\n            mpl.colors.CSS4_COLORS[f'color{i}'] = mpl.colors.to_hex(color)", "test_code_list": [{"test_code": "import pytest\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport numpy.testing as npt\nfrom seaborn import rcmod\nfrom seaborn import palettes\nfrom seaborn import utils\nimport matplotlib.font_manager as mplfm\nclass RCParamFixtures:\n\n    @pytest.fixture(autouse=True)\n    def reset_params(self):\n        yield\n        rcmod.reset_orig()\n\n    def flatten_list(self, orig_list):\n        iter_list = map(np.atleast_1d, orig_list)\n        flat_list = [item for sublist in iter_list for item in sublist]\n        return flat_list\n\n    def assert_rc_params(self, params):\n        for k, v in params.items():\n            if k == 'backend':\n                continue\n            if isinstance(v, np.ndarray):\n                npt.assert_array_equal(mpl.rcParams[k], v)\n            else:\n                assert mpl.rcParams[k] == v\n\n    def assert_rc_params_equal(self, params1, params2):\n        for key, v1 in params1.items():\n            if key == 'backend':\n                continue\n            v2 = params2[key]\n            if isinstance(v1, np.ndarray):\n                npt.assert_array_equal(v1, v2)\n            else:\n                assert v1 == v2\n\nclass TestPalette(RCParamFixtures):\n    def test_set_palette(self):\n        set_palette('deep')\n        assert utils.get_color_cycle() == palettes.color_palette('deep', 10)\n        set_palette('pastel6')\n        assert utils.get_color_cycle() == palettes.color_palette('pastel6', 6)\n        set_palette('dark', 4)\n        assert utils.get_color_cycle() == palettes.color_palette('dark', 4)\n        set_palette('Set2', color_codes=True)\n        assert utils.get_color_cycle() == palettes.color_palette('Set2', 8)\n        assert mpl.colors.same_color(mpl.rcParams['patch.facecolor'], palettes.\n            color_palette()[0])\n    \nTestPalette().test_set_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_rcmod.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_current_palette(self):\n        pal = palettes.color_palette(['red', 'blue', 'green'])\n        set_palette(pal)\n        assert pal == utils.get_color_cycle()\n        rcmod.set()\n    \nTestColorPalettes().test_current_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_big_palette_context(self):\n        original_pal = palettes.color_palette('deep', n_colors=8)\n        context_pal = palettes.color_palette('husl', 10)\n        set_palette(original_pal)\n        with palettes.color_palette(context_pal, 10):\n            assert utils.get_color_cycle() == context_pal\n        assert utils.get_color_cycle() == original_pal\n        rcmod.set()\n    \nTestColorPalettes().test_big_palette_context()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import functools\nimport matplotlib as mpl\nfrom cycler import cycler\n\n\ndef set_palette(palette, n_colors=None, desat=None, color_codes=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_statistics.py", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg):\n    if arg is None:\n        return 'ci', 1.96  # Default to 95% confidence interval\n\n    if callable(arg):\n        return arg, None  # Return the callable and no level\n\n    if isinstance(arg, str):\n        method = arg\n        if method not in ['ci', 'pi', 'se', 'sd']:\n            raise ValueError(f\"Invalid method: {method}. Must be one of 'ci', 'pi', 'se', 'sd'.\")\n        return method, 1.96 if method == 'ci' else None  # Default level for 'ci'\n\n    if isinstance(arg, tuple) and len(arg) == 2:\n        method, level = arg\n        if not isinstance(level, (Number)) or level <= 0:\n            raise ValueError(\"Level must be a positive number.\")\n        if method not in ['ci', 'pi', 'se', 'sd']:\n            raise ValueError(f\"Invalid method: {method}. Must be one of 'ci', 'pi', 'se', 'sd'.\")\n        return method, level\n\n    raise TypeError(\"Argument must be None, a callable, a string, or a tuple of (string, number).\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_statistics.py", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg):\n    if arg is None:\n        return 'ci', 1.96  # Default to 95% confidence interval\n    elif callable(arg):\n        return arg, None  # Custom method provided\n    elif isinstance(arg, str):\n        method = arg\n        if method in ['ci', 'pi', 'se', 'sd']:\n            return method, 1.96 if method == 'ci' else 1  # Default levels\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n    elif isinstance(arg, tuple) and len(arg) == 2:\n        method, level = arg\n        if not isinstance(level, (Number)) or level <= 0:\n            raise ValueError(\"Level must be a positive number.\")\n        if method not in ['ci', 'pi', 'se', 'sd'] and not callable(method):\n            raise ValueError(f\"Unknown method: {method}\")\n        return method, level\n    else:\n        raise ValueError(\"Invalid argument format.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_statistics.py", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg):\n    if arg is None:\n        return 'ci', 1.96  # Default to 95% confidence interval\n    elif callable(arg):\n        return arg, None  # Custom method provided\n    elif isinstance(arg, str):\n        method = arg\n        if method not in ['ci', 'pi', 'se', 'sd']:\n            raise ValueError(f\"Invalid method: {method}. Must be one of 'ci', 'pi', 'se', 'sd'.\")\n        return method, 1.96 if method == 'ci' else None  # Default level for 'ci'\n    elif isinstance(arg, tuple) and len(arg) == 2:\n        method, level = arg\n        if not isinstance(level, (Number)) or level <= 0:\n            raise ValueError(\"Level must be a positive number.\")\n        if method not in ['ci', 'pi', 'se', 'sd']:\n            raise ValueError(f\"Invalid method: {method}. Must be one of 'ci', 'pi', 'se', 'sd'.\")\n        return method, level\n    else:\n        raise ValueError(\"Invalid argument format. Must be None, callable, string, or tuple.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_statistics.py", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg):\n    if arg is None:\n        return 'ci', 1.96  # Default to 95% confidence interval\n\n    if callable(arg):\n        return arg, None  # Return the callable as the method\n\n    if isinstance(arg, str):\n        if arg in ['ci', 'pi', 'se', 'sd']:\n            return arg, 1.96 if arg == 'ci' else 1  # Default levels for 'ci' and others\n        else:\n            raise ValueError(f\"Invalid method string: {arg}\")\n\n    if isinstance(arg, tuple) and len(arg) == 2:\n        method, level = arg\n        if method not in ['ci', 'pi', 'se', 'sd'] and not callable(method):\n            raise ValueError(f\"Invalid method in tuple: {method}\")\n        if not isinstance(level, (Number)) or level <= 0:\n            raise ValueError(f\"Invalid level in tuple: {level}\")\n        return method, level\n\n    raise ValueError(f\"Invalid argument type: {type(arg)}\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_validate_errorbar_arg", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_statistics.py", "response": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg):\n    if arg is None:\n        return 'ci', 1.96  # Default to 95% confidence interval\n    elif callable(arg):\n        return arg, None  # Custom method provided\n    elif isinstance(arg, str):\n        method = arg\n        if method in ['ci', 'pi', 'se', 'sd']:\n            return method, 1.96 if method == 'ci' else 1  # Default levels for 'ci' and others\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n    elif isinstance(arg, tuple) and len(arg) == 2:\n        method, level = arg\n        if not isinstance(level, (Number)) or level <= 0:\n            raise ValueError(\"Level must be a positive number.\")\n        if method not in ['ci', 'pi', 'se', 'sd'] and not callable(method):\n            raise ValueError(f\"Unknown method: {method}\")\n        return method, level\n    else:\n        raise ValueError(\"Invalid argument format.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport statsmodels.distributions as smdist\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn._statistics import KDE\nfrom seaborn._statistics import Histogram\nfrom seaborn._statistics import ECDF\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn._statistics import _validate_errorbar_arg\nfrom seaborn._statistics import _no_scipy\n\nclass TestEstimateAggregator():\n    def test_errorbar_validation(self):\n        method, level = _validate_errorbar_arg(('ci', 99))\n        assert method == 'ci'\n        assert level == 99\n        method, level = _validate_errorbar_arg('sd')\n        assert method == 'sd'\n        assert level == 1\n        f = lambda x: (x.min(), x.max())\n        method, level = _validate_errorbar_arg(f)\n        assert method is f\n        assert level is None\n        bad_args = [('sem', ValueError), (('std', 2), ValueError), (('pi', 5, \n            95), ValueError), (95, TypeError), (('ci', 'large'), TypeError)]\n        for arg, exception in bad_args:\n            with pytest.raises(exception, match='`errorbar` must be'):\n                _validate_errorbar_arg(arg)\n    \nTestEstimateAggregator().test_errorbar_validation()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_statistics.py"}], "method_code_mask": "from numbers import Number\nfrom statistics import NormalDist\nimport numpy as np\nimport pandas as pd\nfrom scipy.stats import gaussian_kde\n\n\ndef _validate_errorbar_arg(arg): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "palplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/miscplot.py", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1):\n    # Set the figure size based on the scaling factor\n    plt.figure(figsize=(len(pal) * size, size))\n    \n    # Create a horizontal bar plot with the colors\n    plt.barh(range(len(pal)), [1] * len(pal), color=pal)\n    \n    # Hide the y-axis and the ticks\n    plt.yticks([])\n    plt.gca().xaxis.set_major_locator(ticker.NullLocator())\n    \n    # Display the plot\n    plt.show()", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "palplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/miscplot.py", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1):\n    # Set the figure size based on the scaling factor\n    plt.figure(figsize=(len(pal) * size, size))\n    \n    # Create a horizontal bar plot with the colors\n    plt.barh(range(len(pal)), [1] * len(pal), color=pal)\n    \n    # Hide the y-axis and its ticks\n    plt.yticks([])\n    \n    # Set the x-axis limits\n    plt.xlim(0, 1)\n    \n    # Hide the x-axis ticks\n    plt.xticks([])\n    \n    # Show the plot\n    plt.show()", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "palplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/miscplot.py", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1):\n    # Set the figure size based on the scaling factor\n    plt.figure(figsize=(len(pal) * size, size))\n    \n    # Create a horizontal bar plot with the colors\n    plt.barh(range(len(pal)), [1] * len(pal), color=pal)\n    \n    # Hide the y-axis and ticks\n    plt.yticks([])\n    plt.gca().xaxis.set_major_locator(ticker.NullLocator())\n    \n    # Show the plot\n    plt.show()", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "palplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/miscplot.py", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1):\n    # Set the figure size based on the scaling factor\n    plt.figure(figsize=(len(pal) * size, size))\n    \n    # Create a horizontal bar plot with the colors\n    plt.barh(range(len(pal)), [1] * len(pal), color=pal)\n    \n    # Hide the y-axis\n    plt.yticks([])\n    \n    # Set the x-axis limits\n    plt.xlim(0, 1)\n    \n    # Hide the x-axis ticks\n    plt.xticks([])\n    \n    # Show the plot\n    plt.show()", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "palplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/miscplot.py", "response": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1):\n    # Set the figure size based on the scaling factor\n    plt.figure(figsize=(len(pal) * size, size))\n    \n    # Create a horizontal bar plot with the colors\n    plt.barh(range(len(pal)), [1] * len(pal), color=pal)\n    \n    # Hide the y-axis and its ticks\n    plt.yticks([])\n    \n    # Set the x-axis limits\n    plt.xlim(0, 1)\n    \n    # Hide the x-axis ticks\n    plt.xticks([])\n    \n    # Show the plot\n    plt.show()", "test_code_list": [{"test_code": "import matplotlib.pyplot as plt\nfrom seaborn import miscplot as misc\nfrom seaborn.palettes import color_palette\n\nclass TestPalPlot():\n    def test_palplot_size(self):\n        pal4 = color_palette('husl', 4)\n        palplot(pal4)\n        size4 = plt.gcf().get_size_inches()\n        assert tuple(size4) == (4, 1)\n        pal5 = color_palette('husl', 5)\n        palplot(pal5)\n        size5 = plt.gcf().get_size_inches()\n        assert tuple(size5) == (5, 1)\n        palbig = color_palette('husl', 3)\n        palplot(palbig, 2)\n        sizebig = plt.gcf().get_size_inches()\n        assert tuple(sizebig) == (6, 2)\n    \nTestPalPlot().test_palplot_size()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_miscplot.py"}], "method_code_mask": "import numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport matplotlib.ticker as ticker\nfrom urllib.request import urlopen\nfrom io import BytesIO\n\n\ndef palplot(pal, size=1): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/matrix.py", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask=None):\n    if mask is None:\n        mask = np.zeros(data.shape, dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask DataFrame must have the same shape as data DataFrame.\")\n        mask = mask.values\n    elif isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask ndarray must have the same shape as data DataFrame.\")\n    else:\n        raise TypeError(\"Mask must be a pandas DataFrame or a numpy ndarray.\")\n\n    # Automatically mark missing values in data as True in the mask\n    mask |= np.isnan(data.values)\n\n    return pd.DataFrame(mask, index=data.index, columns=data.columns)", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/matrix.py", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask=None):\n    if mask is None:\n        mask = np.zeros(data.shape, dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask DataFrame must have the same shape as data DataFrame.\")\n        mask = mask.values\n    elif isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask ndarray must have the same shape as data DataFrame.\")\n    else:\n        raise TypeError(\"Mask must be a pandas DataFrame or a numpy ndarray.\")\n\n    # Automatically mark missing values in data as True in the mask\n    mask |= np.isnan(data.values)\n\n    return pd.DataFrame(mask, index=data.index, columns=data.columns)", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/matrix.py", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask=None):\n    if mask is None:\n        mask = np.zeros(data.shape, dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask DataFrame must have the same shape as data DataFrame.\")\n        mask = mask.values\n    elif isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask ndarray must have the same shape as data DataFrame.\")\n    else:\n        raise TypeError(\"Mask must be a pandas DataFrame or a numpy ndarray.\")\n\n    # Automatically mark missing values in data as True in the mask\n    missing_mask = pd.isnull(data).values\n    mask = np.logical_or(mask, missing_mask)\n\n    return pd.DataFrame(mask, index=data.index, columns=data.columns)", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/matrix.py", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask=None):\n    if mask is None:\n        mask = np.zeros(data.shape, dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask DataFrame must have the same shape as data DataFrame.\")\n        mask = mask.values\n    elif isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask ndarray must have the same shape as data DataFrame.\")\n    else:\n        raise TypeError(\"Mask must be a pandas DataFrame or a numpy ndarray.\")\n\n    # Automatically mark missing values in data as True in the mask\n    mask |= np.isnan(data.values)\n\n    return pd.DataFrame(mask, index=data.index, columns=data.columns)", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_matrix_mask", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/matrix.py", "response": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask=None):\n    if mask is None:\n        mask = np.zeros(data.shape, dtype=bool)\n    elif isinstance(mask, pd.DataFrame):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask DataFrame must have the same shape as data.\")\n        mask = mask.values\n    elif isinstance(mask, np.ndarray):\n        if mask.shape != data.shape:\n            raise ValueError(\"Mask ndarray must have the same shape as data.\")\n    else:\n        raise TypeError(\"Mask must be a pandas DataFrame or a numpy ndarray.\")\n\n    # Automatically mark missing values in data as True in the mask\n    mask |= np.isnan(data.values)\n\n    return pd.DataFrame(mask, index=data.index, columns=data.columns)", "test_code_list": [{"test_code": "import tempfile\nimport copy\nimport numpy as np\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport pandas as pd\nfrom scipy.spatial import distance\nfrom scipy.cluster import hierarchy\nimport numpy.testing as npt\nimport pandas.testing as pdt\nimport pytest\nfrom seaborn import matrix as mat\nfrom seaborn import color_palette\nfrom seaborn._compat import get_colormap\nfrom seaborn._testing import assert_colors_equal\n\nclass TestHeatmap():\n    def test_missing_data_mask(self):\n        data = pd.DataFrame(np.arange(4, dtype=float).reshape(2, 2))\n        data.loc[0, 0] = np.nan\n        mask = _matrix_mask(data, None)\n        npt.assert_array_equal(mask, [[True, False], [False, False]])\n        mask_in = np.array([[False, True], [False, False]])\n        mask_out = _matrix_mask(data, mask_in)\n        npt.assert_array_equal(mask_out, [[True, True], [False, False]])\n    \nTestHeatmap().test_missing_data_mask()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_matrix.py"}], "method_code_mask": "import warnings\nimport matplotlib as mpl\nfrom matplotlib.collections import LineCollection\nimport matplotlib.pyplot as plt\nfrom matplotlib import gridspec\nimport numpy as np\nimport pandas as pd\nfrom scipy.cluster import hierarchy\n\n\ndef _matrix_mask(data, mask): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Determine the shape of the input arrays\n    shape = args[0].shape\n    n_samples = shape[axis] if axis is not None else len(args[0])\n\n    # Prepare an array to hold the bootstrap results\n    boot_dist = np.empty(n_boot)\n\n    for i in range(n_boot):\n        if units is not None:\n            # Resample based on units\n            sampled_units = np.random.choice(units, size=n_samples, replace=True)\n            resampled_data = [arg[np.isin(units, sampled_units)] for arg in args]\n        else:\n            # Resample the data directly\n            resampled_data = [np.random.choice(arg, size=n_samples, replace=True) for arg in args]\n\n        # Apply the function to the resampled data\n        boot_dist[i] = func(*resampled_data, axis=axis)\n\n    return boot_dist", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Determine the shape of the input arrays\n    shape = args[0].shape\n    n_samples = shape[axis] if axis is not None else len(args[0])\n\n    # Prepare an array to hold the bootstrap results\n    boot_dist = np.empty(n_boot)\n\n    for i in range(n_boot):\n        if units is not None:\n            # Resample based on units\n            sampled_units = np.random.choice(units, size=n_samples, replace=True)\n            resampled_data = [arg[np.isin(units, sampled_units)] for arg in args]\n        else:\n            # Resample the data directly\n            resampled_data = [np.random.choice(arg, size=n_samples, replace=True) for arg in args]\n\n        # Apply the function to the resampled data\n        boot_dist[i] = func(*resampled_data, axis=axis)\n\n    return boot_dist", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', 'mean')\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Determine the function to apply\n    if isinstance(func, str):\n        func = getattr(np, func)\n    \n    # Prepare the output array for bootstrapped statistics\n    boot_dist = np.empty(n_boot)\n\n    # Resampling process\n    for i in range(n_boot):\n        if units is not None:\n            # If units are provided, sample based on those\n            unique_units = np.unique(units)\n            sampled_units = np.random.choice(unique_units, size=len(unique_units), replace=True)\n            resampled_data = [args[j][np.isin(units, sampled_units)] for j in range(len(args))]\n        else:\n            # Sample with replacement from the input arrays\n            resampled_data = [np.random.choice(arg, size=len(arg), replace=True) for arg in args]\n\n        # Apply the function to the resampled data\n        boot_dist[i] = func(*resampled_data, axis=axis)\n\n    return boot_dist", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Check if func is a string and get the corresponding numpy function\n    if isinstance(func, str):\n        func = getattr(np, func)\n\n    # Initialize an array to hold the bootstrap results\n    boot_dist = np.empty(n_boot)\n\n    # If units are provided, we will sample based on those\n    if units is not None:\n        unique_units = np.unique(units)\n        boot_indices = np.random.choice(unique_units, (n_boot, len(unique_units)), replace=True)\n        for i in range(n_boot):\n            sample = [args[j][units == boot_indices[i, j]] for j in range(len(args))]\n            boot_dist[i] = func(*sample, axis=axis)\n    else:\n        # Resample the input arrays with replacement\n        for i in range(n_boot):\n            resampled = [np.random.choice(arg, size=arg.shape[0], replace=True) for arg in args]\n            boot_dist[i] = func(*resampled, axis=axis)\n\n    return boot_dist", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Determine the number of input arrays and their shapes\n    input_arrays = [np.asarray(arg) for arg in args]\n    n_arrays = len(input_arrays)\n    array_shapes = [arr.shape for arr in input_arrays]\n\n    # Check if all input arrays have the same shape along the specified axis\n    if axis is not None:\n        for i in range(1, n_arrays):\n            if array_shapes[i][axis] != array_shapes[0][axis]:\n                raise ValueError(\"All input arrays must have the same shape along the specified axis.\")\n\n    # Prepare to store the bootstrap results\n    boot_dist = np.empty((n_boot, n_arrays))\n\n    for i in range(n_boot):\n        if units is not None:\n            # Resample based on units\n            unique_units = np.unique(units)\n            sampled_units = np.random.choice(unique_units, size=len(unique_units), replace=True)\n            resampled_indices = np.isin(units, sampled_units)\n            resampled_arrays = [arr[resampled_indices] for arr in input_arrays]\n        else:\n            # Resample without units\n            resampled_arrays = [np.random.choice(arr, size=arr.shape[axis], replace=True) for arr in input_arrays]\n\n        # Apply the function to the resampled arrays\n        boot_dist[i] = [func(arr, axis=axis) for arr in resampled_arrays]\n\n    return boot_dist", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap():\n    \"\"\"Test that bootstrapping gives the right answer in dumb cases.\"\"\"\n    a_ones = np.ones(10)\n    n_boot = 5\n    out1 = bootstrap(a_ones, n_boot=n_boot)\n    assert_array_equal(out1, np.ones(n_boot))\n    out2 = bootstrap(a_ones, n_boot=n_boot, func=np.median)\n    assert_array_equal(out2, np.ones(n_boot))\n\ntest_bootstrap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_length():\n    \"\"\"Test that we get a bootstrap array of the right shape.\"\"\"\n    a_norm = np.random.randn(1000)\n    out = bootstrap(a_norm)\n    assert len(out) == 10000\n    n_boot = 100\n    out = bootstrap(a_norm, n_boot=n_boot)\n    assert len(out) == n_boot\n\ntest_bootstrap_length()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_range():\n    \"\"\"Test that bootstrapping a random array stays within the right range.\"\"\"\n    a_norm = np.random.randn(1000)\n    amin, amax = a_norm.min(), a_norm.max()\n    out = bootstrap(a_norm)\n    assert amin <= out.min()\n    assert amax >= out.max()\n\ntest_bootstrap_range()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_multiarg():\n    \"\"\"Test that bootstrap works with multiple input arrays.\"\"\"\n    x = np.vstack([[1, 10] for i in range(10)])\n    y = np.vstack([[5, 5] for i in range(10)])\n\n    def f(x, y):\n        return np.vstack((x, y)).max(axis=0)\n    out_actual = bootstrap(x, y, n_boot=2, func=f)\n    out_wanted = np.array([[5, 10], [5, 10]])\n    assert_array_equal(out_actual, out_wanted)\n\ntest_bootstrap_multiarg()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_axis():\n    \"\"\"Test axis kwarg to bootstrap function.\"\"\"\n    x = np.random.randn(10, 20)\n    n_boot = 100\n    out_default = bootstrap(x, n_boot=n_boot)\n    assert out_default.shape == (n_boot,)\n    out_axis = bootstrap(x, n_boot=n_boot, axis=0)\n    assert out_axis.shape, (n_boot, x.shape[1])\n\ntest_bootstrap_axis()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_seed():\n    \"\"\"Test that we can get reproducible resamples by seeding the RNG.\"\"\"\n    data = np.random.randn(50)\n    seed = 42\n    boots1 = bootstrap(data, seed=seed)\n    boots2 = bootstrap(data, seed=seed)\n    assert_array_equal(boots1, boots2)\n\ntest_bootstrap_seed()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_ols():\n    \"\"\"Test bootstrap of OLS model fit.\"\"\"\n\n    def ols_fit(X, y):\n        XtXinv = np.linalg.inv(np.dot(X.T, X))\n        return XtXinv.dot(X.T).dot(y)\n    X = np.column_stack((np.random.randn(50, 4), np.ones(50)))\n    w = [2, 4, 0, 3, 5]\n    y_noisy = np.dot(X, w) + np.random.randn(50) * 20\n    y_lownoise = np.dot(X, w) + np.random.randn(50)\n    n_boot = 500\n    w_boot_noisy = bootstrap(X, y_noisy, n_boot=n_boot, func=ols_fit)\n    w_boot_lownoise = bootstrap(X, y_lownoise, n_boot=n_boot, func=ols_fit\n        )\n    assert w_boot_noisy.shape == (n_boot, 5)\n    assert w_boot_lownoise.shape == (n_boot, 5)\n    assert w_boot_noisy.std() > w_boot_lownoise.std()\n\ntest_bootstrap_ols()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    if units is not None:\n        integers = np.random.randint\n        func_kwargs = {k: v for k, v in kwargs.items() if k != 'units'}\n        return _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers)\n    else:\n        boot_dist = []\n        for _ in range(n_boot):\n            sample = [np.random.choice(a, size=len(a), replace=True) for a in args]\n            boot_dist.append(func(*sample, axis=axis))\n        return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    if units is None:\n        # Resample data points directly\n        boot_dist = []\n        for _ in range(n_boot):\n            resampled = [np.random.choice(a, size=len(a), replace=True) for a in args]\n            boot_dist.append(func(*resampled, axis=axis))\n    else:\n        # Resample based on units\n        integers = np.random.randint\n        func_kwargs = {k: v for k, v in kwargs.items() if k not in ['n_boot', 'axis', 'units', 'func', 'seed']}\n        boot_dist = _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers)\n\n    return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    if units is not None:\n        integers = np.random.randint\n        func_kwargs = {k: v for k, v in kwargs.items() if k != 'units' and k != 'func'}\n        return _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers)\n    else:\n        boot_dist = []\n        for _ in range(n_boot):\n            sample = [np.random.choice(a, size=len(a), replace=True) for a in args]\n            boot_dist.append(func(*sample, axis=axis, **{k: v for k, v in kwargs.items() if k != 'func'}))\n        return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    if units is not None:\n        integers = np.random.randint\n        func_kwargs = {k: v for k, v in kwargs.items() if k != 'units' and k != 'func' and k != 'n_boot' and k != 'seed'}\n        return _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers)\n    else:\n        boot_dist = []\n        for _ in range(n_boot):\n            sample = [np.random.choice(a, size=len(a), replace=True) for a in args]\n            boot_dist.append(func(*sample, axis=axis, **{k: v for k, v in kwargs.items() if k != 'n_boot' and k != 'seed'}))\n        return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "bootstrap", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/algorithms.py", "response": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs):\n    n_boot = kwargs.get('n_boot', 10000)\n    axis = kwargs.get('axis', None)\n    units = kwargs.get('units', None)\n    func = kwargs.get('func', np.mean)\n    seed = kwargs.get('seed', None)\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    if units is not None:\n        integers = np.random.randint\n        func_kwargs = {k: v for k, v in kwargs.items() if k != 'units' and k != 'func'}\n        return _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers)\n    else:\n        boot_dist = []\n        for _ in range(n_boot):\n            sample = [np.random.choice(a, size=len(a), replace=True) for a in args]\n            boot_dist.append(func(*sample, axis=axis, **{k: v for k, v in kwargs.items() if k != 'func'}))\n        return np.array(boot_dist)", "test_code_list": [{"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_units():\n    \"\"\"Test that results make sense when passing unit IDs to bootstrap.\"\"\"\n    data = np.random.randn(50)\n    ids = np.repeat(range(10), 5)\n    bwerr = np.random.normal(0, 2, 10)\n    bwerr = bwerr[ids]\n    data_rm = data + bwerr\n    seed = 77\n    boots_orig = bootstrap(data_rm, seed=seed)\n    boots_rm = bootstrap(data_rm, units=ids, seed=seed)\n    assert boots_rm.std() > boots_orig.std()\n\ntest_bootstrap_units()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_string_func():\n    \"\"\"Test that named numpy methods are the same as the numpy function.\"\"\"\n    x = np.random.randn(100)\n    res_a = bootstrap(x, func='mean', seed=0)\n    res_b = bootstrap(x, func=np.mean, seed=0)\n    assert np.array_equal(res_a, res_b)\n    res_a = bootstrap(x, func='std', seed=0)\n    res_b = bootstrap(x, func=np.std, seed=0)\n    assert np.array_equal(res_a, res_b)\n    with pytest.raises(AttributeError):\n        bootstrap(x, func='not_a_method_name')\n\ntest_bootstrap_string_func()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_bootstrap_reproducibility():\n    \"\"\"Test that bootstrapping uses the internal random state.\"\"\"\n    data = np.random.randn(50)\n    boots1 = bootstrap(data, seed=100)\n    boots2 = bootstrap(data, seed=100)\n    assert_array_equal(boots1, boots2)\n    random_state1 = np.random.RandomState(200)\n    boots1 = bootstrap(data, seed=random_state1)\n    random_state2 = np.random.RandomState(200)\n    boots2 = bootstrap(data, seed=random_state2)\n    assert_array_equal(boots1, boots2)\n    with pytest.warns(UserWarning):\n        boots1 = bootstrap(data, random_seed=100)\n        boots2 = bootstrap(data, random_seed=100)\n        assert_array_equal(boots1, boots2)\n\ntest_bootstrap_reproducibility()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_auto():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    boots = bootstrap(x, func='mean')\n    assert not np.isnan(boots).any()\n\ntest_nanaware_func_auto()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}, {"test_code": "import numpy as np\nimport pytest\nfrom numpy.testing import assert_array_equal\nfrom seaborn import algorithms as algo\ndef test_nanaware_func_warning():\n    x = np.random.normal(size=10)\n    x[0] = np.nan\n    with pytest.warns(UserWarning, match='Data contain nans but'):\n        boots = bootstrap(x, func='ptp')\n    assert np.isnan(boots).any()\n\ntest_nanaware_func_warning()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_algorithms.py"}], "method_code_mask": "import numpy as np\nimport warnings\n\n\ndef _structured_bootstrap(args, n_boot, units, func, func_kwargs, integers):\n    \"\"\"Resample units instead of datapoints.\"\"\"\n    unique_units = np.unique(units)\n    n_units = len(unique_units)\n    args = [[a[units == unit] for unit in unique_units] for a in args]\n    boot_dist = []\n    for i in range(int(n_boot)):\n        resampler = integers(0, n_units, n_units, dtype=np.intp)\n        sample = [[a[i] for i in resampler] for a in args]\n        lengths = map(len, sample[0])\n        resampler = [integers(0, n, n, dtype=np.intp) for n in lengths]\n        sample = [[c.take(r, axis=0) for c, r in zip(a, resampler)] for a in\n            sample]\n        sample = list(map(np.concatenate, sample))\n        boot_dist.append(func(*sample, **func_kwargs))\n    return np.array(boot_dist)\n\n\ndef bootstrap(*args, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"Generate a color palette in HLS color space.\n\n    Args:\n        n_colors (int): Number of colors in the palette.\n        h (float): Starting hue for the first color.\n        l (float): Lightness of the colors.\n        s (float): Saturation of the colors.\n        as_cmap (bool): If True, return a matplotlib colormap object.\n\n    Returns:\n        list or Colormap: A list of RGB tuples or a matplotlib colormap object.\n    \"\"\"\n    hues = [(h + i / n_colors) % 1.0 for i in range(n_colors)]\n    rgb_colors = [colorsys.hls_to_rgb(hue, l, s) for hue in hues]\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(rgb_colors)\n    return rgb_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"Generate a color palette in HLS color space.\"\"\"\n    hues = [(h + i / n_colors) % 1.0 for i in range(n_colors)]\n    rgb_colors = [colorsys.hls_to_rgb(hue, l, s) for hue in hues]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(rgb_colors)\n    \n    return rgb_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"Generate a color palette in HLS color space.\n\n    Args:\n        n_colors (int): Number of colors in the palette.\n        h (float): Starting hue for the first color.\n        l (float): Lightness of the colors.\n        s (float): Saturation of the colors.\n        as_cmap (bool): If True, return a matplotlib colormap object.\n\n    Returns:\n        list or Colormap: A list of RGB tuples or a matplotlib colormap object.\n    \"\"\"\n    hues = [(h + i / n_colors) % 1.0 for i in range(n_colors)]\n    rgb_colors = [colorsys.hls_to_rgb(hue, l, s) for hue in hues]\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(rgb_colors)\n    else:\n        return _ColorPalette(rgb_colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"Generate a color palette in HLS color space.\n\n    Args:\n        n_colors (int): Number of colors in the palette.\n        h (float): Starting hue for the first color.\n        l (float): Lightness of the colors.\n        s (float): Saturation of the colors.\n        as_cmap (bool): If True, return a matplotlib colormap object.\n\n    Returns:\n        list or Colormap: A list of RGB tuples or a matplotlib colormap object.\n    \"\"\"\n    # Generate hues\n    hues = [(h + i / n_colors) % 1.0 for i in range(n_colors)]\n    \n    # Convert HLS to RGB\n    rgb_colors = [colorsys.hls_to_rgb(hue, l, s) for hue in hues]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(rgb_colors)\n    else:\n        return rgb_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "hls_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False):\n    \"\"\"Generate a color palette in HLS color space.\"\"\"\n    hues = [(h + i / n_colors) % 1.0 for i in range(n_colors)]\n    rgb_colors = [colorsys.hls_to_rgb(hue, l, s) for hue in hues]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(rgb_colors)\n    \n    return rgb_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_palette(self):\n        pal1 = hls_palette()\n        pal2 = palettes.color_palette('hls')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = hls_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('hls', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_hls_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_hls_values(self):\n        pal1 = hls_palette(6, h=0)\n        pal2 = hls_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = hls_palette(5, l=0.2)\n        pal_bright = hls_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = hls_palette(5, s=0.1)\n        pal_bold = hls_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_hls_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef hls_palette(n_colors=6, h=0.01, l=0.6, s=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nimport husl  # Assuming husl is a library that provides the husl_to_rgb function\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"Generate a color palette with hues sampled evenly in the HUSL color space.\"\"\"\n    hues = np.linspace(h, h + 1, n_colors, endpoint=False)\n    colors = [husl.husl_to_rgb(hue, s, l) for hue in hues]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nimport husl  # Assuming husl is a module that provides the husl_to_rgb function\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"Generate a color palette with hues sampled evenly in the HUSL color space.\"\"\"\n    hues = np.linspace(h, h + 1, n_colors, endpoint=False)  # Generate n_colors evenly spaced hues\n    colors = [husl.husl_to_rgb(hue, s, l) for hue in hues]  # Convert hues to RGB using HUSL\n    colors = [tuple(np.clip(color, 0, 1)) for color in colors]  # Ensure colors are within RGB bounds\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)  # Return a colormap if as_cmap is True\n    return _ColorPalette(colors)  # Return a list of colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nimport husl  # Assuming husl is a library that provides the husl_to_rgb function\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"Generate a color palette with hues sampled evenly in the HUSL color space.\"\"\"\n    hues = np.linspace(h, h + 1, n_colors, endpoint=False)\n    colors = [husl.husl_to_rgb(hue, s, l) for hue in hues]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nimport husl  # Assuming husl is a library that provides the husl_to_rgb function\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"Generate a color palette with hues sampled evenly in the HUSL color space.\"\"\"\n    hues = np.linspace(h, h + 1, n_colors, endpoint=False)  # Generate n_colors evenly spaced hues\n    colors = [husl.husl_to_rgb(hue, s, l) for hue in hues]  # Convert to RGB using HUSL\n    colors = [tuple(np.clip(color, 0, 1)) for color in colors]  # Ensure colors are in the range [0, 1]\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)  # Return as a colormap if as_cmap is True\n    return _ColorPalette(colors)  # Return as a list of colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "husl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nimport husl  # Assuming husl is a library that provides the husl_to_rgb function\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False):\n    \"\"\"Generate a color palette with hues sampled evenly in the HUSL color space.\"\"\"\n    hues = np.linspace(h, h + 1, n_colors, endpoint=False)  # Generate evenly spaced hues\n    colors = [husl.husl_to_rgb(hue, s, l) for hue in hues]  # Convert to RGB using HUSL\n    colors = [tuple(np.clip(color, 0, 1)) for color in colors]  # Ensure colors are in [0, 1]\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)  # Return as a colormap if requested\n    return _ColorPalette(colors)  # Return as a color palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_palette(self):\n        pal1 = husl_palette()\n        pal2 = palettes.color_palette('husl')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = husl_palette(as_cmap=True)\n        cmap2 = palettes.color_palette('husl', as_cmap=True)\n        npt.assert_array_equal(cmap1([0.2, 0.8]), cmap2([0.2, 0.8]))\n    \nTestColorPalettes().test_husl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_palette_desat(self):\n        pal1 = husl_palette(6)\n        pal1 = [utils.desaturate(c, 0.5) for c in pal1]\n        pal2 = palettes.color_palette('husl', desat=0.5)\n        npt.assert_array_equal(pal1, pal2)\n    \nTestColorPalettes().test_palette_desat()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_husl_values(self):\n        pal1 = husl_palette(6, h=0)\n        pal2 = husl_palette(6, h=0.5)\n        pal2 = pal2[3:] + pal2[:3]\n        npt.assert_array_almost_equal(pal1, pal2)\n        pal_dark = husl_palette(5, l=0.2)\n        pal_bright = husl_palette(5, l=0.8)\n        npt.assert_array_less(list(map(sum, pal_dark)), list(map(sum, pal_bright)))\n        pal_flat = husl_palette(5, s=0.1)\n        pal_bold = husl_palette(5, s=0.9)\n        npt.assert_array_less(list(map(np.std, pal_flat)), list(map(np.std,\n            pal_bold)))\n    \nTestColorPalettes().test_husl_values()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef husl_palette(n_colors=6, h=0.01, s=0.9, l=0.65, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    if name not in MPL_QUAL_PALS:\n        raise ValueError(f\"Palette '{name}' is not recognized.\")\n    \n    cmap = mpl.cm.get_cmap(name, MPL_QUAL_PALS[name])\n    colors = [cmap(i) for i in range(n_colors)]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    else:\n        return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    if name not in MPL_QUAL_PALS:\n        raise ValueError(f\"Palette '{name}' is not recognized. Available palettes: {list(MPL_QUAL_PALS.keys())}\")\n\n    # Get the number of colors in the palette\n    num_colors = MPL_QUAL_PALS[name]\n    \n    # Generate the color palette\n    cmap = mpl.cm.get_cmap(name, num_colors)\n    colors = [cmap(i)[:3] for i in range(num_colors)]  # Get RGB values\n\n    # If n_colors is specified, interpolate the colors\n    if n_colors != num_colors:\n        colors = [cmap(i * (num_colors - 1) / (n_colors - 1))[:3] for i in range(n_colors)]\n\n    # Return as ListedColormap or _ColorPalette\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    else:\n        return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    \"\"\"Generate a color palette from the matplotlib registry.\"\"\"\n    if name not in MPL_QUAL_PALS:\n        raise ValueError(f\"Palette '{name}' is not recognized. Available palettes: {list(MPL_QUAL_PALS.keys())}\")\n\n    # Get the colormap\n    cmap = mpl.cm.get_cmap(name, n_colors)\n\n    # Generate the colors\n    colors = [cmap(i) for i in range(n_colors)]\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    else:\n        return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    if name not in MPL_QUAL_PALS:\n        raise ValueError(f\"Palette '{name}' is not recognized.\")\n    \n    # Get the number of colors for the specified palette\n    num_colors = MPL_QUAL_PALS[name]\n    \n    # Generate a color map based on the palette name\n    cmap = mpl.cm.get_cmap(name, num_colors)\n    \n    # Get the colors from the colormap\n    colors = [cmap(i) for i in range(num_colors)]\n    \n    # If n_colors is less than the number of colors in the palette, sample the colors\n    if n_colors < num_colors:\n        colors = colors[:n_colors]\n    \n    # Return as a ListedColormap or a list of RGB tuples\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    else:\n        return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "mpl_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False):\n    \"\"\"Generate a color palette from the matplotlib registry.\"\"\"\n    if name not in MPL_QUAL_PALS:\n        raise ValueError(f\"Palette '{name}' is not recognized.\")\n    \n    # Get the colormap\n    cmap = mpl.cm.get_cmap(name, MPL_QUAL_PALS[name])\n    \n    # Generate the colors\n    colors = [cmap(i) for i in range(n_colors)]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    else:\n        return _ColorPalette(colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_mpl_palette(self):\n        pal1 = mpl_palette('Reds')\n        pal2 = palettes.color_palette('Reds')\n        npt.assert_array_equal(pal1, pal2)\n        cmap1 = get_colormap('Reds')\n        cmap2 = mpl_palette('Reds', as_cmap=True)\n        cmap3 = palettes.color_palette('Reds', as_cmap=True)\n        npt.assert_array_equal(cmap1, cmap2)\n        npt.assert_array_equal(cmap1, cmap3)\n    \nTestColorPalettes().test_mpl_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\nMPL_QUAL_PALS = {'tab10': 10, 'tab20': 20, 'tab20b': 20, 'tab20c': 20,\n    'Set1': 9, 'Set2': 8, 'Set3': 12, 'Accent': 8, 'Paired': 12, 'Pastel1':\n    9, 'Pastel2': 8, 'Dark2': 8}\n\n\ndef mpl_palette(name, n_colors=6, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input):\n    if input == 'hls':\n        # Convert HLS to RGB\n        rgb = colorsys.hls_to_rgb(color[0], color[1], color[2])\n    elif input == 'husl':\n        # Convert HUSL to RGB\n        from husl import husl_to_rgb\n        rgb = husl_to_rgb(color[0], color[1], color[2])\n    elif input == 'xkcd':\n        # Convert XKCD color name to RGB\n        rgb = mpl.colors.XKCD_COLORS[color]\n    else:\n        raise ValueError(\"Unsupported color input format. Use 'hls', 'husl', or 'xkcd'.\")\n\n    # Ensure the RGB values are in the range [0, 1]\n    return tuple(np.clip(rgb, 0, 1))", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input):\n    if input == 'hls':\n        # Convert HLS to RGB\n        return colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        # Convert HUSL to RGB\n        from husl import husl_to_rgb\n        return husl_to_rgb(*color)\n    elif input == 'xkcd':\n        # Convert XKCD color name to RGB\n        rgb = mpl.colors.XKCD_COLORS[color]\n        return mpl.colors.to_rgb(rgb)\n    else:\n        raise ValueError(\"Unsupported color input type. Use 'hls', 'husl', or 'xkcd'.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input):\n    if input == 'hls':\n        # Convert HLS to RGB\n        rgb = colorsys.hls_to_rgb(color[0], color[1], color[2])\n    elif input == 'husl':\n        # Convert HUSL to RGB\n        from husl import husl_to_rgb\n        rgb = husl_to_rgb(color[0], color[1], color[2])\n    elif input == 'xkcd':\n        # Convert XKCD color name to RGB\n        rgb = mpl.colors.XKCD_COLORS[color]\n    else:\n        raise ValueError(\"Unsupported color input format. Use 'hls', 'husl', or 'xkcd'.\")\n\n    # Normalize RGB values to be in the range of 0 to 1\n    return tuple(np.clip(rgb, 0, 1))", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input):\n    if input == 'hls':\n        # Convert HLS to RGB\n        rgb = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        # Convert HUSL to RGB\n        from husl import husl_to_rgb\n        rgb = husl_to_rgb(*color)\n    elif input == 'xkcd':\n        # Convert XKCD color name to RGB\n        rgb = mpl.colors.XKCD_COLORS[color]\n    else:\n        raise ValueError(\"Unsupported color input type. Use 'hls', 'husl', or 'xkcd'.\")\n    \n    # Ensure RGB values are in the range [0, 1]\n    return tuple(np.clip(rgb, 0, 1))", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_color_to_rgb", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input):\n    if input == 'hls':\n        # Convert HLS to RGB\n        rgb = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        # Convert HUSL to RGB\n        from husl import husl_to_rgb\n        rgb = husl_to_rgb(*color)\n    elif input == 'xkcd':\n        # Convert XKCD color name to RGB\n        rgb = mpl.colors.XKCD_COLORS[color]\n    else:\n        raise ValueError(\"Unsupported color input type. Use 'hls', 'husl', or 'xkcd'.\")\n\n    # Ensure the output is a tuple of RGB values in the range [0, 1]\n    return tuple(np.clip(rgb, 0, 1))", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_hls(self):\n        color = 0.5, 0.8, 0.4\n        rgb_got = _color_to_rgb(color, 'hls')\n        rgb_want = colorsys.hls_to_rgb(*color)\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_hls()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_husl(self):\n        color = 120, 50, 40\n        rgb_got = _color_to_rgb(color, 'husl')\n        rgb_want = tuple(husl.husl_to_rgb(*color))\n        assert rgb_got == rgb_want\n        for h in range(0, 360):\n            color = h, 100, 100\n            rgb = _color_to_rgb(color, 'husl')\n            assert min(rgb) >= 0\n            assert max(rgb) <= 1\n    \nTestColorPalettes().test_rgb_from_husl()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_rgb_from_xkcd(self):\n        color = 'dull red'\n        rgb_got = _color_to_rgb(color, 'xkcd')\n        rgb_want = mpl.colors.to_rgb(xkcd_rgb[color])\n        assert rgb_got == rgb_want\n    \nTestColorPalettes().test_rgb_from_xkcd()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _color_to_rgb(color, input): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a dark color palette that blends from a dark shade to a specified color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        If True, the direction of the blend is reversed. Default is False.\n    as_cmap : bool, optional\n        If True, return a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n    input : str, optional\n        Color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    dark_color = tuple(max(0, c - 0.5) for c in base_color)  # Create a darker shade\n    colors = [dark_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=False)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(palette)\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a dark color palette that blends from a dark shade to a specified color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        If True, the direction of the blend is reversed. Default is False.\n    as_cmap : bool, optional\n        If True, return a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n    input : str, optional\n        Color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    dark_color = tuple(max(0, c - 0.5) for c in base_color)  # Create a darker shade\n    colors = [dark_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=False)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(palette)\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a dark color palette that blends from a dark shade to a specified color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        If True, the direction of the blend is reversed. Default is False.\n    as_cmap : bool, optional\n        If True, return a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n    input : str, optional\n        The color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    dark_color = tuple(max(0, c - 0.5) for c in base_color)  # Create a darker shade\n    colors = [dark_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=False)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(palette)\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a dark color palette that blends from a dark shade to a specified color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        If True, the direction of the blend is reversed. Default is False.\n    as_cmap : bool, optional\n        If True, return a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n    input : str, optional\n        Color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples representing the color palette, or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    dark_color = tuple(max(0, c - 0.5) for c in base_color)  # Create a darker shade\n    colors = [dark_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=False)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(palette)\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "dark_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'):\n    \"\"\"Create a dark color palette that blends from a dark shade to a specified color.\n    \n    Parameters\n    ----------\n    color : str or tuple\n        The base color for high values in the palette.\n    n_colors : int, optional\n        Number of colors in the palette. Default is 6.\n    reverse : bool, optional\n        If True, the direction of the blend is reversed. Default is False.\n    as_cmap : bool, optional\n        If True, return a matplotlib ListedColormap instead of a list of RGB tuples. Default is False.\n    input : str, optional\n        Color space to interpret the input color. Options are 'rgb', 'hls', 'husl', or 'xkcd'. Default is 'rgb'.\n    \n    Returns\n    -------\n    palette : list or ListedColormap\n        A list of RGB tuples or a matplotlib ListedColormap.\n    \"\"\"\n    base_color = _color_to_rgb(color, input)\n    dark_color = tuple(max(0, c - 0.5) for c in base_color)  # Create a darker shade\n    colors = [dark_color, base_color]\n    \n    palette = blend_palette(colors, n_colors=n_colors, as_cmap=False)\n    \n    if reverse:\n        palette = palette[::-1]\n    \n    if as_cmap:\n        return mpl.colors.ListedColormap(palette)\n    \n    return palette", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_dark_palette(self):\n        n = 4\n        pal_forward = dark_palette('red', n)\n        pal_reverse = dark_palette('red', n, reverse=True)\n        assert np.allclose(pal_forward, pal_reverse[::-1])\n        red = mpl.colors.colorConverter.to_rgb('red')\n        assert pal_forward[-1] == red\n        pal_f_from_string = palettes.color_palette('dark:red', n)\n        assert pal_forward[3] == pal_f_from_string[3]\n        pal_r_from_string = palettes.color_palette('dark:red_r', n)\n        assert pal_reverse[3] == pal_r_from_string[3]\n        pal_cmap = dark_palette('blue', as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        pal_cmap_from_string = palettes.color_palette('dark:blue', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n        pal_cmap = dark_palette('blue', as_cmap=True, reverse=True)\n        pal_cmap_from_string = palettes.color_palette('dark:blue_r', as_cmap=True)\n        assert pal_cmap(0.8) == pal_cmap_from_string(0.8)\n    \nTestColorPalettes().test_dark_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Make a palette that blends between a list of colors.\n    Parameters\n    ----------\n    colors : sequence of colors in various formats interpreted by `input`\n        hex code, html color name, or tuple in `input` space.\n    n_colors : int, optional\n        Number of colors in the palette.\n    as_cmap : bool, optional\n        If True, return a :class:`matplotlib.colors.ListedColormap`.\n    Returns\n    -------\n    palette\n        list of RGB tuples or :class:`matplotlib.colors.ListedColormap`\n    Examples\n    --------\n    .. include: ../docstrings/blend_palette.rst\n    \"\"\"\n    colors = [_color_to_rgb(color, input) for color in colors]\n    name = 'blend'\n    pal = mpl.colors.LinearSegmentedColormap.from_list(name, colors)\n    if not as_cmap:\n        rgb_array = pal(np.linspace(0, 1, int(n_colors)))[:, :3]\n        pal = _ColorPalette(map(tuple, rgb_array))\n    return pal\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef dark_palette(color, n_colors=6, reverse=False, as_cmap=False, input='rgb'\n    ): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Blend a list of colors into a palette.\n\n    Args:\n        colors: A sequence of colors.\n        n_colors: Number of colors in the palette.\n        as_cmap: If True, return a matplotlib colormap.\n        input: Color space of the input colors.\n\n    Returns:\n        A list of RGB tuples or a matplotlib colormap.\n    \"\"\"\n    # Convert colors to RGB\n    rgb_colors = [_color_to_rgb(color, input) for color in colors]\n    \n    # Create a blended palette\n    blended_colors = []\n    for i in range(n_colors):\n        ratio = i / (n_colors - 1)\n        color = np.array(rgb_colors[0]) * (1 - ratio) + np.array(rgb_colors[-1]) * ratio\n        blended_colors.append(tuple(color))\n    \n    if as_cmap:\n        return mpl.colors.LinearSegmentedColormap.from_list(\"custom_palette\", blended_colors)\n    \n    return blended_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Blend a list of colors into a palette.\n\n    Args:\n        colors: A sequence of colors.\n        n_colors: Number of colors in the palette.\n        as_cmap: If True, return a matplotlib colormap.\n        input: Color space of the input colors.\n\n    Returns:\n        A list of RGB tuples or a matplotlib colormap.\n    \"\"\"\n    # Convert colors to RGB\n    rgb_colors = [_color_to_rgb(color, input) for color in colors]\n    \n    # Create a blended palette\n    blended_colors = []\n    for i in range(n_colors):\n        ratio = i / (n_colors - 1)\n        color = tuple((1 - ratio) * rgb_colors[0][j] + ratio * rgb_colors[-1][j] for j in range(3))\n        blended_colors.append(color)\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(blended_colors)\n    return blended_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Blend a list of colors into a palette.\n\n    Args:\n        colors: A sequence of colors.\n        n_colors: Number of colors in the palette (default is 6).\n        as_cmap: If True, return a matplotlib colormap (default is False).\n        input: Color space of the input colors (default is 'rgb').\n\n    Returns:\n        A list of RGB tuples or a matplotlib colormap.\n    \"\"\"\n    # Convert colors to RGB\n    rgb_colors = [_color_to_rgb(color, input) for color in colors]\n\n    # Create a blended palette\n    blended_colors = []\n    for i in range(n_colors):\n        ratio = i / (n_colors - 1)\n        color = tuple((1 - ratio) * rgb_colors[0][j] + ratio * rgb_colors[-1][j] for j in range(3))\n        blended_colors.append(color)\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(blended_colors)\n    else:\n        return _ColorPalette(blended_colors)", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Blend a list of colors into a palette.\n\n    Args:\n        colors: A sequence of colors.\n        n_colors: Number of colors in the palette.\n        as_cmap: Whether to return a colormap.\n        input: Color space of the input colors.\n\n    Returns:\n        A list of RGB tuples or a matplotlib colormap.\n    \"\"\"\n    # Convert colors to RGB\n    rgb_colors = [_color_to_rgb(color, input) for color in colors]\n    \n    # Create a blended palette\n    blended_colors = []\n    for i in range(n_colors):\n        ratio = i / (n_colors - 1)\n        color = tuple((1 - ratio) * rgb_colors[0][j] + ratio * rgb_colors[-1][j] for j in range(3))\n        blended_colors.append(color)\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(blended_colors)\n    \n    return blended_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "blend_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'):\n    \"\"\"Blend a list of colors into a palette.\n\n    Args:\n        colors: A sequence of colors.\n        n_colors: Number of colors in the palette.\n        as_cmap: If True, return a matplotlib colormap.\n        input: Color space of the input colors.\n\n    Returns:\n        A list of RGB tuples or a matplotlib colormap.\n    \"\"\"\n    # Convert colors to RGB\n    rgb_colors = [_color_to_rgb(color, input) for color in colors]\n    \n    # Create a blended palette\n    blended_colors = []\n    for i in range(n_colors):\n        ratio = i / (n_colors - 1)\n        color = tuple((1 - ratio) * rgb_colors[0][j] + ratio * rgb_colors[-1][j] for j in range(3))\n        blended_colors.append(color)\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(blended_colors)\n    \n    return blended_colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_blend_palette(self):\n        colors = ['red', 'yellow', 'white']\n        pal_cmap = blend_palette(colors, as_cmap=True)\n        assert isinstance(pal_cmap, mpl.colors.LinearSegmentedColormap)\n        colors = ['red', 'blue']\n        pal = blend_palette(colors)\n        pal_str = 'blend:' + ','.join(colors)\n        pal_from_str = palettes.color_palette(pal_str)\n        assert pal == pal_from_str\n    \nTestColorPalettes().test_blend_palette()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef _color_to_rgb(color, input):\n    \"\"\"Add some more flexibility to color choices.\"\"\"\n    if input == 'hls':\n        color = colorsys.hls_to_rgb(*color)\n    elif input == 'husl':\n        color = husl.husl_to_rgb(*color)\n        color = tuple(np.clip(color, 0, 1))\n    elif input == 'xkcd':\n        color = xkcd_rgb[color]\n    return mpl.colors.to_rgb(color)\n\n\ndef blend_palette(colors, n_colors=6, as_cmap=False, input='rgb'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \n    # Calculate the range of lightness values\n    lightness_range = np.linspace(dark, light, n_colors)\n    \n    # Calculate the hue values\n    hues = [(start + rot * i) % 3 for i in range(n_colors)]\n    \n    # Generate RGB values\n    colors = []\n    for l, h in zip(lightness_range, hues):\n        r, g, b = colorsys.hls_to_rgb(h, l, gamma)\n        colors.append((r, g, b))\n    \n    # Reverse colors if needed\n    if reverse:\n        colors.reverse()\n    \n    # Return as colormap if as_cmap is True\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \n    # Generate the cubehelix colors\n    colors = []\n    for i in range(n_colors):\n        fraction = (i / (n_colors - 1)) if n_colors > 1 else 0\n        h = (start + rot * fraction) % 3\n        l = dark + (light - dark) * (fraction ** gamma)\n        r, g, b = colorsys.hls_to_rgb(h, l, hue)\n        colors.append((r, g, b))\n\n    if reverse:\n        colors.reverse()\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \n    # Calculate the range of colors\n    colors = []\n    for i in range(n_colors):\n        fraction = float(i) / (n_colors - 1)\n        # Calculate the lightness\n        lightness = dark + (light - dark) * fraction ** gamma\n        # Calculate the hue\n        h = (start + rot * fraction) % 1.0\n        # Convert to RGB\n        r, g, b = colorsys.hls_to_rgb(h, lightness, hue)\n        colors.append((r, g, b))\n\n    if reverse:\n        colors.reverse()\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \n    # Calculate the range of brightness values\n    lightness_range = np.linspace(dark, light, n_colors)\n    \n    # Generate the colors\n    colors = []\n    for i in range(n_colors):\n        # Calculate the hue for the current color\n        h = (start + rot * i) % 3\n        # Adjust the brightness using gamma\n        r, g, b = colorsys.hls_to_rgb(h, lightness_range[i] ** gamma, hue)\n        colors.append((r, g, b))\n    \n    # Reverse the colors if needed\n    if reverse:\n        colors.reverse()\n    \n    # Return as a colormap if requested\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "cubehelix_palette", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False):\n    \n    # Generate the cubehelix colors\n    colors = []\n    for i in range(n_colors):\n        fraction = (i / (n_colors - 1)) if n_colors > 1 else 0\n        h = (start + rot * fraction) % 3\n        l = dark + (light - dark) * (fraction ** gamma)\n        r, g, b = colorsys.hls_to_rgb(h, l, hue)\n        colors.append((r, g, b))\n\n    if reverse:\n        colors.reverse()\n\n    if as_cmap:\n        return mpl.colors.ListedColormap(colors)\n    \n    return colors", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_against_matplotlib(self):\n        x = np.linspace(0, 1, 8)\n        mpl_pal = mpl.cm.cubehelix(x)[:, :3].tolist()\n        sns_pal = cubehelix_palette(8, start=0.5, rot=-1.5, hue=1,\n            dark=0, light=1, reverse=True)\n        assert sns_pal == mpl_pal\n    \nTestColorPalettes().test_cubehelix_against_matplotlib()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_n_colors(self):\n        for n in [3, 5, 8]:\n            pal = cubehelix_palette(n)\n            assert len(pal) == n\n    \nTestColorPalettes().test_cubehelix_n_colors()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_reverse(self):\n        pal_forward = cubehelix_palette()\n        pal_reverse = cubehelix_palette(reverse=True)\n        assert pal_forward == pal_reverse[::-1]\n    \nTestColorPalettes().test_cubehelix_reverse()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}, {"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_cubehelix_cmap(self):\n        cmap = cubehelix_palette(as_cmap=True)\n        assert isinstance(cmap, mpl.colors.ListedColormap)\n        pal = cubehelix_palette()\n        x = np.linspace(0, 1, 6)\n        npt.assert_array_equal(cmap(x)[:, :3], pal)\n        cmap_rev = cubehelix_palette(as_cmap=True, reverse=True)\n        x = np.linspace(0, 1, 6)\n        pal_forward = cmap(x).tolist()\n        pal_reverse = cmap_rev(x[::-1]).tolist()\n        assert pal_forward == pal_reverse\n    \nTestColorPalettes().test_cubehelix_cmap()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\nclass _ColorPalette(list):\n    \"\"\"Set the color palette in a with statement, otherwise be a list.\"\"\"\n\n    def __enter__(self):\n        \"\"\"Open the context.\"\"\"\n        from .rcmod import set_palette\n        self._orig_palette = color_palette()\n        set_palette(self)\n        return self\n\n    def __exit__(self, *args):\n        \"\"\"Close the context.\"\"\"\n        from .rcmod import set_palette\n        set_palette(self._orig_palette)\n\n    def as_hex(self):\n        \"\"\"Return a color palette with hex codes instead of RGB values.\"\"\"\n        hex = [mpl.colors.rgb2hex(rgb) for rgb in self]\n        return _ColorPalette(hex)\n\n    def _repr_html_(self):\n        \"\"\"Rich display of the color palette in an HTML frontend.\"\"\"\n        s = 55\n        n = len(self)\n        html = f'<svg  width=\"{n * s}\" height=\"{s}\">'\n        for i, c in enumerate(self.as_hex()):\n            html += (\n                f'<rect x=\"{i * s}\" y=\"0\" width=\"{s}\" height=\"{s}\" style=\"fill:{c};stroke-width:2;stroke:rgb(255,255,255)\"/>'\n                )\n        html += '</svg>'\n        return html\n\n\ndef cubehelix_palette(n_colors=6, start=0, rot=0.4, gamma=1.0, hue=0.8,\n    light=0.85, dark=0.15, reverse=False, as_cmap=False): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\ndef set_color_codes(palette='deep'):\n    if palette == 'reset':\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=mpl.colors.TABLEAU_COLORS.values())\n    elif palette in SEABORN_PALETTES:\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=SEABORN_PALETTES[palette])\n    else:\n        raise ValueError(f\"Invalid palette name: {palette}. Valid options are: {list(SEABORN_PALETTES.keys()) + ['reset']}.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\ndef set_color_codes(palette='deep'):\n    if palette == 'reset':\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=mpl.colors.TABLEAU_COLORS.values())\n    elif palette in SEABORN_PALETTES:\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=SEABORN_PALETTES[palette])\n    else:\n        raise ValueError(f\"Invalid palette name: {palette}. Valid options are: {list(SEABORN_PALETTES.keys()) + ['reset']}.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\ndef set_color_codes(palette='deep'):\n    if palette == 'reset':\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=mpl.rcParams['axes.color_cycle'])\n    elif palette in SEABORN_PALETTES:\n        colors = SEABORN_PALETTES[palette]\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=colors)\n    else:\n        raise ValueError(f\"Invalid palette name: {palette}. Valid options are: {list(SEABORN_PALETTES.keys()) + ['reset']}.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\ndef set_color_codes(palette='deep'):\n    if palette == 'reset':\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=mpl.rcParams['axes.color_cycle'])\n    elif palette in SEABORN_PALETTES:\n        colors = SEABORN_PALETTES[palette]\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=colors)\n    else:\n        raise ValueError(f\"Invalid palette name: {palette}. Valid options are: {list(SEABORN_PALETTES.keys()) + ['reset']}.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "set_color_codes", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\ndef set_color_codes(palette='deep'):\n    if palette == 'reset':\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=mpl.rcParams['axes.color_cycle'])\n    elif palette in SEABORN_PALETTES:\n        colors = SEABORN_PALETTES[palette]\n        mpl.rcParams['axes.prop_cycle'] = mpl.cycler(color=colors)\n    else:\n        raise ValueError(f\"Invalid palette name: {palette}. Valid options are: {list(SEABORN_PALETTES.keys()) + ['reset']}.\")", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_color_codes(self):\n        set_color_codes('deep')\n        colors = palettes.color_palette('deep6') + ['.1']\n        for code, color in zip('bgrmyck', colors):\n            rgb_want = mpl.colors.colorConverter.to_rgb(color)\n            rgb_got = mpl.colors.colorConverter.to_rgb(code)\n            assert rgb_want == rgb_got\n        set_color_codes('reset')\n        with pytest.raises(ValueError):\n            set_color_codes('Set1')\n    \nTestColorPalettes().test_color_codes()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\nSEABORN_PALETTES = dict(deep=['#4C72B0', '#DD8452', '#55A868', '#C44E52',\n    '#8172B3', '#937860', '#DA8BC3', '#8C8C8C', '#CCB974', '#64B5CD'],\n    deep6=['#4C72B0', '#55A868', '#C44E52', '#8172B3', '#CCB974', '#64B5CD'\n    ], muted=['#4878D0', '#EE854A', '#6ACC64', '#D65F5F', '#956CB4',\n    '#8C613C', '#DC7EC0', '#797979', '#D5BB67', '#82C6E2'], muted6=[\n    '#4878D0', '#6ACC64', '#D65F5F', '#956CB4', '#D5BB67', '#82C6E2'],\n    pastel=['#A1C9F4', '#FFB482', '#8DE5A1', '#FF9F9B', '#D0BBFF',\n    '#DEBB9B', '#FAB0E4', '#CFCFCF', '#FFFEA3', '#B9F2F0'], pastel6=[\n    '#A1C9F4', '#8DE5A1', '#FF9F9B', '#D0BBFF', '#FFFEA3', '#B9F2F0'],\n    bright=['#023EFF', '#FF7C00', '#1AC938', '#E8000B', '#8B2BE2',\n    '#9F4800', '#F14CC1', '#A3A3A3', '#FFC400', '#00D7FF'], bright6=[\n    '#023EFF', '#1AC938', '#E8000B', '#8B2BE2', '#FFC400', '#00D7FF'], dark\n    =['#001C7F', '#B1400D', '#12711C', '#8C0800', '#591E71', '#592F0D',\n    '#A23582', '#3C3C3C', '#B8850A', '#006374'], dark6=['#001C7F',\n    '#12711C', '#8C0800', '#591E71', '#B8850A', '#006374'], colorblind=[\n    '#0173B2', '#DE8F05', '#029E73', '#D55E00', '#CC78BC', '#CA9161',\n    '#FBAFE4', '#949494', '#ECE133', '#56B4E9'], colorblind6=['#0173B2',\n    '#029E73', '#D55E00', '#CC78BC', '#ECE133', '#56B4E9'])\n\n\ndef set_color_codes(palette='deep'): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display():\n    def _repr_png_(self):\n        \"\"\"Return a PNG representation of the colormap.\"\"\"\n        # Create an array of colors\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        # Create a figure and axis\n        fig, ax = plt.subplots(figsize=(6, 1))\n        ax.set_title(self.name)\n        ax.imshow(gradient, aspect='auto', cmap=self)\n        ax.set_axis_off()\n        \n        # Save to a BytesIO object\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)\n        plt.close(fig)\n        buf.seek(0)\n        \n        # Encode to base64\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        return f\"![Colormap]({img_str})\"\n\n    def _repr_html_(self):\n        \"\"\"Return an HTML representation of the colormap.\"\"\"\n        # Create an array of colors\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        # Create a figure and axis\n        fig, ax = plt.subplots(figsize=(6, 1))\n        ax.set_title(self.name)\n        ax.imshow(gradient, aspect='auto', cmap=self)\n        ax.set_axis_off()\n        \n        # Save to a BytesIO object\n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)\n        plt.close(fig)\n        buf.seek(0)\n        \n        # Encode to base64\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        return f'<img src=\"data:image/png;base64,{img_str}\" alt=\"Colormap\" />'\n\n    # Patch the Colormap class\n    mpl.cm.Colormap._repr_png_ = _repr_png_\n    mpl.cm.Colormap._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display():\n    def _repr_png_(self):\n        \"\"\"Return a PNG representation of the colormap.\"\"\"\n        # Create an array of colors from the colormap\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        # Create an image from the gradient\n        img = Image.fromarray(np.uint8(self(gradient) * 255))\n        # Save the image to a bytes buffer\n        buf = io.BytesIO()\n        img.save(buf, format='PNG')\n        # Encode the image to base64\n        return f\"data:image/png;base64,{base64.b64encode(buf.getvalue()).decode()}\"\n\n    def _repr_html_(self):\n        \"\"\"Return an HTML representation of the colormap.\"\"\"\n        # Create an HTML representation of the colormap\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        img = Image.fromarray(np.uint8(self(gradient) * 255))\n        buf = io.BytesIO()\n        img.save(buf, format='PNG')\n        img_str = base64.b64encode(buf.getvalue()).decode()\n        return f'<img src=\"data:image/png;base64,{img_str}\" />'\n\n    # Patch the Colormap class\n    mpl.cm.Colormap._repr_png_ = _repr_png_\n    mpl.cm.Colormap._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display():\n    colormap = mpl.cm.ScalarMappable(cmap=mpl.cm.viridis)\n    \n    def _repr_png_(self):\n        \"\"\"Return a PNG representation of the colormap.\"\"\"\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        fig, ax = plt.subplots(figsize=(6, 1))\n        ax.imshow(gradient, aspect='auto', cmap=self.cmap)\n        ax.set_axis_off()\n        \n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)\n        plt.close(fig)\n        buf.seek(0)\n        return buf.getvalue()\n\n    def _repr_html_(self):\n        \"\"\"Return an HTML representation of the colormap.\"\"\"\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        img = Image.fromarray((gradient * 255).astype(np.uint8))\n        buf = io.BytesIO()\n        img.save(buf, format='PNG')\n        buf.seek(0)\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        return f'<img src=\"data:image/png;base64,{img_str}\" width=\"600\" height=\"50\"/>'\n\n    # Patch the Colormap class\n    mpl.cm.ScalarMappable._repr_png_ = _repr_png_\n    mpl.cm.ScalarMappable._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display():\n    colormap = mpl.cm.ScalarMappable(cmap=mpl.cm.viridis)\n    \n    def _repr_png_(self):\n        # Create an image of the colormap\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        img = colormap.to_rgba(gradient)\n        img = (img[:, :, :3] * 255).astype(np.uint8)  # Convert to 8-bit RGB\n        pil_img = Image.fromarray(img)\n        \n        # Save the image to a bytes buffer\n        buf = io.BytesIO()\n        pil_img.save(buf, format='PNG')\n        buf.seek(0)\n        \n        # Encode the image to base64\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        return f\"![Colormap]data:image/png;base64,{img_str}\"\n\n    def _repr_html_(self):\n        # Generate HTML representation of the colormap\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        img = colormap.to_rgba(gradient)\n        img = (img[:, :, :3] * 255).astype(np.uint8)  # Convert to 8-bit RGB\n        pil_img = Image.fromarray(img)\n        \n        # Save the image to a bytes buffer\n        buf = io.BytesIO()\n        pil_img.save(buf, format='PNG')\n        buf.seek(0)\n        \n        # Encode the image to base64\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        return f'<img src=\"data:image/png;base64,{img_str}\" alt=\"Colormap\" style=\"width:100%;\"/>'\n\n    # Patch the Colormap class\n    mpl.cm.ScalarMappable._repr_png_ = _repr_png_\n    mpl.cm.ScalarMappable._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "_patch_colormap_display", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/palettes.py", "response": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display():\n    colormap = mpl.cm.ScalarMappable(cmap=mpl.cm.viridis)\n    \n    def _repr_png_(self):\n        \"\"\"Return a PNG representation of the colormap.\"\"\"\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        fig, ax = plt.subplots(figsize=(6, 1))\n        ax.set_title(self.get_cmap().name)\n        ax.imshow(gradient, aspect='auto', cmap=self.get_cmap())\n        ax.set_axis_off()\n        \n        buf = io.BytesIO()\n        plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)\n        plt.close(fig)\n        buf.seek(0)\n        return buf.getvalue()\n\n    def _repr_html_(self):\n        \"\"\"Return an HTML representation of the colormap.\"\"\"\n        gradient = np.linspace(0, 1, 256)\n        gradient = np.vstack((gradient, gradient))\n        img = Image.fromarray((gradient * 255).astype(np.uint8))\n        buf = io.BytesIO()\n        img.save(buf, format='png')\n        buf.seek(0)\n        img_str = base64.b64encode(buf.read()).decode('utf-8')\n        html = f'<img src=\"data:image/png;base64,{img_str}\" alt=\"{self.get_cmap().name}\" style=\"width:600px; height:50px;\"/>'\n        return html\n\n    mpl.cm.Colormap._repr_png_ = _repr_png_\n    mpl.cm.Colormap._repr_html_ = _repr_html_", "test_code_list": [{"test_code": "import colorsys\nimport numpy as np\nimport matplotlib as mpl\nimport pytest\nimport numpy.testing as npt\nfrom seaborn import palettes\nfrom seaborn import utils\nfrom seaborn import rcmod\nfrom seaborn.external import husl\nfrom seaborn._compat import get_colormap\nfrom seaborn.colors import xkcd_rgb\nfrom seaborn.colors import crayons\n\nclass TestColorPalettes():\n    def test_colormap_display_patch(self):\n        orig_repr_png = getattr(mpl.colors.Colormap, '_repr_png_', None)\n        orig_repr_html = getattr(mpl.colors.Colormap, '_repr_html_', None)\n        try:\n            _patch_colormap_display()\n            cmap = mpl.cm.Reds\n            assert cmap._repr_html_().startswith('<img alt=\"Reds')\n        finally:\n            if orig_repr_png is not None:\n                mpl.colors.Colormap._repr_png_ = orig_repr_png\n            if orig_repr_html is not None:\n                mpl.colors.Colormap._repr_html_ = orig_repr_html\n    \nTestColorPalettes().test_colormap_display_patch()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_palettes.py"}], "method_code_mask": "import colorsys\nfrom itertools import cycle\nimport numpy as np\nimport matplotlib as mpl\nimport io\nfrom PIL import Image\nimport base64\n\n\ndef _patch_colormap_display(): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "countplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/categorical.py", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, fill=True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0, log_scale=None, native_scale=False, formatter=None, legend='auto', ax=None, **kwargs):\n    # Check for valid input\n    if data is None:\n        raise ValueError(\"Data must be provided for countplot.\")\n    \n    # Determine orientation\n    orient = infer_orient(x, y)\n    \n    # Prepare the data for plotting\n    if orient == 'v':\n        data_to_plot = data[x]\n        count_data = data[y]\n    else:\n        data_to_plot = data[y]\n        count_data = data[x]\n    \n    # Count occurrences\n    counts = count_data.value_counts().reindex(order).fillna(0)\n    \n    # Create the plot\n    if ax is None:\n        ax = plt.gca()\n    \n    # Create bars\n    bars = ax.bar(counts.index, counts.values, width=width, color=color, **kwargs)\n    \n    # Set properties\n    ax.set_ylabel(stat.capitalize() + ' Count')\n    ax.set_title('Countplot')\n    \n    # Handle hue if provided\n    if hue is not None:\n        # Additional logic for hue handling can be added here\n        pass\n    \n    # Return the axes object\n    return ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "countplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/categorical.py", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, fill=True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0, log_scale=None, native_scale=False, formatter=None, legend='auto', ax=None, **kwargs):\n    # Validate inputs\n    _check_argument(data, \"data\", (pd.DataFrame, pd.Series, np.ndarray))\n    \n    # Determine orientation\n    orient = infer_orient(x, y)\n    \n    # Prepare the data for plotting\n    if orient == 'v':\n        plot_data = data[x]\n        if hue is not None:\n            hue_data = data[hue]\n    else:\n        plot_data = data[y]\n        if hue is not None:\n            hue_data = data[hue]\n    \n    # Count the occurrences\n    counts = plot_data.value_counts().reindex(order).fillna(0)\n    \n    # Create the bars\n    if ax is None:\n        ax = plt.gca()\n    \n    bars = ax.bar(counts.index, counts.values, width=width, color=color, **kwargs)\n    \n    # Apply hue if specified\n    if hue is not None:\n        for bar, hue_value in zip(bars, hue_data):\n            bar.set_color(palette[hue_value])\n    \n    # Set the legend\n    if legend != False:\n        handles, labels = ax.get_legend_handles_labels()\n        if legend == 'brief':\n            ax.legend(handles, [hue] if hue else labels)\n        elif legend == 'full':\n            ax.legend(handles, labels)\n    \n    # Return the axes object\n    return ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "countplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/categorical.py", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, fill=True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0, log_scale=None, native_scale=False, formatter=None, legend='auto', ax=None, **kwargs):\n    # Check if data is provided\n    if data is None:\n        raise ValueError(\"Data must be provided for countplot.\")\n\n    # Determine orientation\n    orient = infer_orient(x, y)\n    \n    # Prepare the data for plotting\n    if orient == 'v':\n        plot_data = data[x]\n    else:\n        plot_data = data[y]\n\n    # Create the count data\n    count_data = plot_data.value_counts().reset_index()\n    count_data.columns = [plot_data.name, 'count']\n\n    # Create the plot\n    if ax is None:\n        ax = plt.gca()\n\n    # Plot the bars\n    if orient == 'v':\n        bars = ax.bar(count_data[plot_data.name], count_data['count'], width=width, color=color, **kwargs)\n    else:\n        bars = ax.barh(count_data[plot_data.name], count_data['count'], height=width, color=color, **kwargs)\n\n    # Set the legend if required\n    if legend != False:\n        ax.legend(bars, count_data[plot_data.name], title=hue)\n\n    # Return the axes object\n    return ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "countplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/categorical.py", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, fill=True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0, log_scale=None, native_scale=False, formatter=None, legend='auto', ax=None, **kwargs):\n    # Check if data is provided\n    if data is None:\n        raise ValueError(\"Data must be provided for countplot.\")\n\n    # Determine orientation\n    orient = infer_orient(x, y)\n\n    # Prepare the data for plotting\n    if orient == 'v':\n        plot_data = data[x]\n    else:\n        plot_data = data[y]\n\n    # Count occurrences\n    counts = plot_data.value_counts()\n\n    # Create the bar plot\n    if ax is None:\n        ax = plt.gca()\n\n    bars = ax.bar(counts.index, counts.values, width=width, color=color, **kwargs)\n\n    # Set the legend if required\n    if legend != False:\n        handles, labels = ax.get_legend_handles_labels()\n        if legend == 'brief':\n            ax.legend(handles, [hue] if hue else labels)\n        elif legend == 'full':\n            ax.legend(handles, labels)\n\n    # Set additional properties\n    ax.set_title('Count Plot')\n    ax.set_xlabel(x if x is not None else '')\n    ax.set_ylabel('Count')\n\n    return ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "countplot", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/categorical.py", "response": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order=None, orient=None, color=None, palette=None, saturation=0.75, fill=True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0, log_scale=None, native_scale=False, formatter=None, legend='auto', ax=None, **kwargs):\n    # Check the orientation\n    orient = infer_orient(x, y)\n    \n    # Prepare the data\n    if isinstance(data, pd.DataFrame):\n        data = data.copy()\n    \n    # Create the plotter\n    plotter = VectorPlotter(data=data, x=x, y=y, hue=hue, order=order, hue_order=hue_order, orient=orient, stat=stat, width=width, dodge=dodge, gap=gap, log_scale=log_scale, native_scale=native_scale, formatter=formatter, legend=legend, ax=ax, **kwargs)\n    \n    # Draw the plot\n    plotter.draw(saturation=saturation, fill=fill, color=color, palette=palette)\n    \n    return plotter.ax", "test_code_list": [{"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_empty(self):\n        ax = countplot()\n        assert not ax.patches\n        ax = countplot(x=[])\n        assert not ax.patches\n    \nTestCountPlot().test_empty()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_flat_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_flat_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_x_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n    \nTestCountPlot().test_x_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_y_series(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(y=vals)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() == 0\n            assert bar.get_y() + bar.get_height() / 2 == approx(i)\n            assert bar.get_height() == approx(0.8)\n            assert bar.get_width() == counts[i]\n    \nTestCountPlot().test_y_series()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_redundant(self):\n        vals = ['a', 'b', 'c']\n        counts = [2, 1, 4]\n        vals = pd.Series([x for x, n in zip(vals, counts) for _ in range(n)])\n        ax = countplot(x=vals, hue=vals, saturation=1)\n        for i, bar in enumerate(ax.patches):\n            assert bar.get_x() + bar.get_width() / 2 == approx(i)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8)\n            assert same_color(bar.get_facecolor(), f'C{i}')\n    \nTestCountPlot().test_hue_redundant()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}, {"test_code": "import itertools\nfrom functools import partial\nimport warnings\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import same_color\nfrom matplotlib.colors import to_rgb\nfrom matplotlib.colors import to_rgba\nimport pytest\nfrom pytest import approx\nfrom numpy.testing import assert_array_equal\nfrom numpy.testing import assert_array_less\nfrom numpy.testing import assert_array_almost_equal\nfrom seaborn import categorical as cat\nfrom seaborn._base import categorical_order\nfrom seaborn._compat import get_colormap\nfrom seaborn._compat import get_legend_handles\nfrom seaborn._testing import assert_plots_equal\nfrom seaborn.categorical import _CategoricalPlotter\nfrom seaborn.categorical import Beeswarm\nfrom seaborn.categorical import BoxPlotContainer\nfrom seaborn.categorical import catplot\nfrom seaborn.categorical import barplot\nfrom seaborn.categorical import boxplot\nfrom seaborn.categorical import boxenplot\nfrom seaborn.categorical import countplot\nfrom seaborn.categorical import pointplot\nfrom seaborn.categorical import stripplot\nfrom seaborn.categorical import swarmplot\nfrom seaborn.categorical import violinplot\nfrom seaborn.palettes import color_palette\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _version_predates\nfrom seaborn.utils import desaturate\n\nclass TestCountPlot():\n    def test_hue_dodged(self):\n        vals = ['a', 'a', 'a', 'b', 'b', 'b']\n        hue = ['x', 'y', 'y', 'x', 'x', 'x']\n        counts = [1, 3, 2, 0]\n        ax = countplot(x=vals, hue=hue, saturation=1, legend=False)\n        for i, bar in enumerate(ax.patches):\n            sign = 1 if i // 2 else -1\n            assert bar.get_x() + bar.get_width() / 2 == approx(i % 2 + sign * \n                0.8 / 4)\n            assert bar.get_y() == 0\n            assert bar.get_height() == counts[i]\n            assert bar.get_width() == approx(0.8 / 2)\n            assert same_color(bar.get_facecolor(), f'C{i // 2}')\n    \nTestCountPlot().test_hue_dodged()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/test_categorical.py"}], "method_code_mask": "from collections import namedtuple\nfrom textwrap import dedent\nimport warnings\nfrom colorsys import rgb_to_hls\nfrom functools import partial\nimport numpy as np\nimport pandas as pd\nimport matplotlib as mpl\nfrom matplotlib.cbook import normalize_kwargs\nfrom matplotlib.collections import PatchCollection\nfrom matplotlib.markers import MarkerStyle\nfrom matplotlib.patches import Rectangle\nimport matplotlib.pyplot as plt\nfrom seaborn._core.typing import default\nfrom seaborn._core.typing import deprecated\nfrom seaborn._base import VectorPlotter\nfrom seaborn._base import infer_orient\nfrom seaborn._base import categorical_order\nfrom seaborn._stats.density import KDE\nfrom seaborn import utils\nfrom seaborn.utils import desaturate\nfrom seaborn.utils import _check_argument\nfrom seaborn.utils import _draw_figure\nfrom seaborn.utils import _default_color\nfrom seaborn.utils import _get_patch_legend_artist\nfrom seaborn.utils import _get_transform_functions\nfrom seaborn.utils import _scatter_legend_artist\nfrom seaborn.utils import _version_predates\nfrom seaborn._compat import groupby_apply_include_groups\nfrom seaborn._statistics import EstimateAggregator\nfrom seaborn._statistics import LetterValues\nfrom seaborn._statistics import WeightedAggregator\nfrom seaborn.palettes import light_palette\nfrom seaborn.axisgrid import FacetGrid\nfrom seaborn.axisgrid import _facet_docs\n\n\ndef countplot(data=None, *, x=None, y=None, hue=None, order=None, hue_order\n    =None, orient=None, color=None, palette=None, saturation=0.75, fill=\n    True, hue_norm=None, stat='count', width=0.8, dodge='auto', gap=0,\n    log_scale=None, native_scale=False, formatter=None, legend='auto', ax=\n    None, **kwargs): [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) -> list:\n    if order is not None:\n        # If a custom order is provided, use it\n        ordered_categories = order\n    else:\n        # Otherwise, get unique values from the vector and sort them\n        ordered_categories = vector.dropna().unique()\n        ordered_categories = sorted(ordered_categories, key=lambda x: (isinstance(x, str), x))\n\n    # Return the ordered categories as a list\n    return list(ordered_categories)", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) -> list:\n    if order is not None:\n        # If a custom order is provided, use it\n        ordered_categories = order\n    else:\n        # Otherwise, get unique values from the vector and sort them\n        unique_values = vector.dropna().unique()\n        ordered_categories = sorted(unique_values, key=lambda x: (isinstance(x, str), x))\n\n    # Exclude null values from the final output\n    return [cat for cat in ordered_categories if pd.notna(cat)]", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) -> list:\n    if order is not None:\n        # If a custom order is provided, use it\n        ordered_categories = order\n    else:\n        # Otherwise, get the unique categories from the vector\n        ordered_categories = vector.dropna().unique()\n    \n    # Convert to a list and sort according to seaborn's rules\n    ordered_categories = sorted(ordered_categories, key=lambda x: (isinstance(x, str), x))\n    \n    return list(ordered_categories)", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) -> list:\n    if order is not None:\n        # If a custom order is provided, use it\n        ordered_categories = order\n    else:\n        # Otherwise, get the unique values from the vector and sort them\n        ordered_categories = vector.dropna().unique()\n        ordered_categories = sorted(ordered_categories, key=lambda x: (isinstance(x, str), x))\n\n    # Return the ordered categories as a list, excluding any null values\n    return [cat for cat in ordered_categories if pd.notna(cat)]", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "categorical_order", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) -> list:\n    if order is not None:\n        # If a custom order is provided, use it\n        ordered_categories = order\n    else:\n        # Otherwise, derive the order from the unique values in the vector\n        ordered_categories = vector.dropna().unique()\n        ordered_categories = sorted(ordered_categories, key=lambda x: (isinstance(x, str), x))\n\n    # Remove duplicates while preserving order\n    ordered_categories = list(dict.fromkeys(ordered_categories))\n\n    return ordered_categories", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_categorical_order():\n    x = pd.Series(['a', 'c', 'c', 'b', 'a', 'd'])\n    y = pd.Series([3, 2, 5, 1, 4])\n    order = ['a', 'b', 'c', 'd']\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n    out = categorical_order(x, order)\n    assert out == order\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    out = categorical_order(y)\n    assert out == [1, 2, 3, 4, 5]\n    out = categorical_order(pd.Series(y))\n    assert out == [1, 2, 3, 4, 5]\n    y_cat = pd.Series(pd.Categorical(y, y))\n    out = categorical_order(y_cat)\n    assert out == list(y)\n    x = pd.Series(x).astype('category')\n    out = categorical_order(x)\n    assert out == list(x.cat.categories)\n    out = categorical_order(x, ['b', 'a'])\n    assert out == ['b', 'a']\n    x = pd.Series(['a', np.nan, 'c', 'c', 'b', 'a', 'd'])\n    out = categorical_order(x)\n    assert out == ['a', 'c', 'b', 'd']\n\ntest_categorical_order()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef categorical_order(vector: Series, order: (list | None)=None) ->list: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\nclass VarType(UserString):\n    pass\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) -> VarType:\n    \n    if isinstance(vector, (pd.Series, np.ndarray, list, tuple)):\n        if pd.api.types.is_numeric_dtype(vector):\n            return VarType('numeric')\n        \n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return VarType('datetime')\n        \n        if pd.api.types.is_categorical_dtype(vector) or pd.api.types.is_object_dtype(vector):\n            if strict_boolean and vector.dropna().dtype == 'bool':\n                return VarType('boolean')\n            elif not strict_boolean and all((x in [0, 1, np.nan] for x in vector)):\n                return VarType(boolean_type)\n            else:\n                return VarType('categorical')\n    \n    raise ValueError(\"Input must be a pandas Series, numpy ndarray, or Python sequence.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\nclass VarType(UserString):\n    pass\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) -> VarType:\n    \n    if isinstance(vector, (pd.Series, np.ndarray, list, tuple)):\n        if pd.api.types.is_numeric_dtype(vector):\n            return VarType('numeric')\n        \n        elif pd.api.types.is_datetime64_any_dtype(vector):\n            return VarType('datetime')\n        \n        elif pd.api.types.is_categorical_dtype(vector) or pd.api.types.is_object_dtype(vector):\n            if strict_boolean and vector.dropna().dtype == 'bool':\n                return VarType('boolean')\n            elif not strict_boolean and all((x in [0, 1, np.nan] for x in vector.dropna())):\n                return VarType(boolean_type)\n            else:\n                return VarType('categorical')\n    \n    warnings.warn(\"Input vector is not a recognized type.\")\n    return VarType('unknown')", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\nclass VarType(UserString):\n    pass\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) -> VarType:\n    \n    if isinstance(vector, (pd.Series, np.ndarray, list, tuple)):\n        # Check for datetime\n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return VarType('datetime')\n        \n        # Check for boolean\n        if strict_boolean:\n            if pd.api.types.is_bool_dtype(vector):\n                return VarType('boolean')\n        else:\n            if pd.api.types.is_bool_dtype(vector) or (vector.dropna().isin([0, 1]).all() and vector.notna().any()):\n                return VarType(boolean_type)\n\n        # Check for numeric\n        if pd.api.types.is_numeric_dtype(vector):\n            return VarType('numeric')\n        \n        # If not numeric, check for categorical\n        return VarType('categorical')\n    \n    raise ValueError(\"Input must be a pandas Series, numpy ndarray, or a Python sequence.\")", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\nclass VarType(UserString):\n    pass\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) -> VarType:\n    \n    if isinstance(vector, (pd.Series, np.ndarray, list, tuple)):\n        if pd.api.types.is_numeric_dtype(vector):\n            return VarType('numeric')\n        \n        elif pd.api.types.is_datetime64_any_dtype(vector):\n            return VarType('datetime')\n        \n        elif pd.api.types.is_categorical_dtype(vector) or pd.api.types.is_object_dtype(vector):\n            if strict_boolean and vector.dropna().dtype == 'bool':\n                return VarType('boolean')\n            elif not strict_boolean and all((x in [0, 1, np.nan] for x in vector.dropna())):\n                return VarType(boolean_type)\n            else:\n                return VarType('categorical')\n    \n    warnings.warn(\"Input vector is not a recognized type.\")\n    return VarType('unknown')", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
{"model_name": "gpt-4o-mini", "repository": "seaborn", "full_method_name": "variable_type", "method_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/seaborn/_core/rules.py", "response": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\nclass VarType(UserString):\n    pass\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) -> VarType:\n    \n    if isinstance(vector, (pd.Series, np.ndarray, list, tuple)):\n        if pd.api.types.is_numeric_dtype(vector):\n            return VarType('numeric')\n        \n        if pd.api.types.is_datetime64_any_dtype(vector):\n            return VarType('datetime')\n        \n        if pd.api.types.is_categorical_dtype(vector) or pd.api.types.is_object_dtype(vector):\n            if strict_boolean and vector.dtype == 'bool':\n                return VarType('boolean')\n            elif not strict_boolean and all((x in [0, 1, np.nan] for x in vector)):\n                return VarType(boolean_type)\n            else:\n                return VarType('categorical')\n    \n    warnings.warn(\"Input vector is not a recognized type.\")\n    return VarType('unknown')", "test_code_list": [{"test_code": "import numpy as np\nimport pandas as pd\nimport pytest\nfrom seaborn._core.rules import VarType\nfrom seaborn._core.rules import variable_type\nfrom seaborn._core.rules import categorical_order\ndef test_variable_type():\n    s = pd.Series([1.0, 2.0, 3.0])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s.astype(int)) == 'numeric'\n    assert variable_type(s.astype(object)) == 'numeric'\n    s = pd.Series([1, 2, 3, np.nan], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([np.nan, np.nan])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([pd.NA, pd.NA])\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype='Int64')\n    assert variable_type(s) == 'numeric'\n    s = pd.Series([1, 2, pd.NA], dtype=object)\n    assert variable_type(s) == 'numeric'\n    s = pd.Series(['1', '2', '3'])\n    assert variable_type(s) == 'categorical'\n    s = pd.Series([True, False, False])\n    assert variable_type(s) == 'numeric'\n    assert variable_type(s, boolean_type='categorical') == 'categorical'\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.timedelta_range(1, periods=3, freq='D').to_series()\n    assert variable_type(s) == 'categorical'\n    s_cat = s.astype('category')\n    assert variable_type(s_cat, boolean_type='categorical') == 'categorical'\n    assert variable_type(s_cat, boolean_type='numeric') == 'categorical'\n    assert variable_type(s_cat, boolean_type='boolean') == 'categorical'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    assert variable_type(s, boolean_type='boolean', strict_boolean=True\n        ) == 'numeric'\n    s = pd.Series([1, 0, 0])\n    assert variable_type(s, boolean_type='boolean') == 'boolean'\n    s = pd.Series([pd.Timestamp(1), pd.Timestamp(2)])\n    assert variable_type(s) == 'datetime'\n    assert variable_type(s.astype(object)) == 'datetime'\n\ntest_variable_type()\n", "code_start": "", "test_path": "/home/zhuqiming2022/workspace/doceb/../srcdata/Visualization/seaborn/tests/_core/test_rules.py"}], "method_code_mask": "from __future__ import annotations\nimport warnings\nfrom collections import UserString\nfrom numbers import Number\nfrom datetime import datetime\nimport numpy as np\nimport pandas as pd\nfrom typing import TYPE_CHECKING\nfrom typing import Literal\nfrom pandas import Series\n\n\ndef variable_type(vector: Series, boolean_type: Literal['numeric',\n    'categorical', 'boolean']='numeric', strict_boolean: bool=False\n    ) ->VarType: [MASK]\n"}
